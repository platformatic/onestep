function isParsedValueRuntype(e) {
  return "tag" in e && "parsed" === e.tag;
}
function ParsedValue(e, t) {
  return (
    assertRuntype(e),
    create(
      "parsed",
      {
        p: (r, n, a) =>
          ((e, t, r) => {
            if (!e.success) return e;
            if (!e.cycle) {
              const n = t(e.value);
              return (n.success && r && innerGuard(r, n.value, createGuardVisitedState())) || n;
            }
            return innerMapValidationPlaceholder(
              Array.isArray(e.placeholder) ? [...e.placeholder] : { ...e.placeholder },
              () => e.unwrap(),
              t,
              r,
            );
          })(a(e, r), e => t.parse(e), t.test),
        t(r, n) {
          return t.test
            ? n(t.test, r)
            : failure((t.name || `ParsedValue<${show(e)}>`) + " does not support Runtype.test");
        },
        s(r, n, a) {
          if (!t.serialize)
            return failure(
              (t.name || `ParsedValue<${show(e)}>`) + " does not support Runtype.serialize",
            );
          const s = t.test ? innerGuard(t.test, r, createGuardVisitedState()) : void 0;
          if (s) return s;
          const o = t.serialize(r);
          return o.success ? a(e, o.value) : o;
        },
      },
      {
        underlying: e,
        config: t,
        show() {
          return t.name || `ParsedValue<${show(e, !1)}>`;
        },
      },
    )
  );
}
function assertRuntype(...e) {
  for (const r of e) if (!r || !r[t]) throw new Error("Expected Runtype but got " + showValue(r));
}
function create(e, r, n) {
  function safeParse(e) {
    return innerValidate(a, e, createVisitedState());
  }
  function safeSerialize(e) {
    return innerSerialize(a, e, createVisitedState());
  }
  const a = {
    ...n,
    tag: e,
    assert(e) {
      const t = innerGuard(a, e, createGuardVisitedState());
      if (t) throw new ValidationError(t);
    },
    parse(e) {
      const t = safeParse(e);
      if (!t.success) throw new ValidationError(t);
      return t.value;
    },
    safeParse,
    test: e => void 0 === innerGuard(a, e, createGuardVisitedState()),
    serialize(e) {
      const t = safeSerialize(e);
      if (!t.success) throw new ValidationError(t);
      return t.value;
    },
    safeSerialize,
    Or: e => Union(a, e),
    And: e => Intersect(a, e),
    withConstraint: (e, t) => Constraint(a, e, t),
    withGuard: (e, t) => Constraint(a, e, t),
    withBrand: e => Brand(e, a),
    withParser: e => ParsedValue(a, e),
    toString: () => `Runtype<${show(a)}>`,
    [t]: "function" == typeof r ? { p: r } : r,
  };
  return a;
}
function createValidationPlaceholder(e, t) {
  return innerMapValidationPlaceholder(e, () => t(e) || success(e));
}
function innerMapValidationPlaceholder(e, t, r, n) {
  let a,
    s = !1;
  const o = {
    success: !0,
    cycle: !0,
    placeholder: e,
    unwrap() {
      if (a) return (s = !0), a;
      a = success(e);
      const i = t(),
        u = i.success && r ? r(i.value) : i;
      if (!u.success) return (a = u);
      if (s) {
        const e = ((e, t) =>
            e === t
              ? success(t)
              : Array.isArray(e) && Array.isArray(t)
              ? (e.splice(0, e.length, ...t), success(e))
              : e &&
                "object" == typeof e &&
                !Array.isArray(e) &&
                t &&
                "object" == typeof t &&
                !Array.isArray(t)
              ? (Object.assign(e, t), success(e))
              : failure(
                  `Cannot convert a value of type "${
                    Array.isArray(e) ? "Array" : typeof e
                  }" into a value of type "${
                    null === t ? "null" : Array.isArray(t) ? "Array" : typeof t
                  }" when it contains cycles.`,
                ))(a.value, u.value),
          t = e.success && n && innerGuard(n, e.value, createGuardVisitedState());
        a = t || e;
      } else {
        const e = n && innerGuard(n, u.value, createGuardVisitedState());
        a = e || u;
      }
      return a.success && (o.placeholder = a.value), a;
    },
  };
  return o;
}
function createVisitedState() {
  return new Map();
}
function createGuardVisitedState() {
  return new Map();
}
function innerValidate(e, t, r) {
  const n = innerValidateToPlaceholder(e, t, r);
  return n.cycle ? n.unwrap() : n;
}
function innerValidateToPlaceholder(e, r, n) {
  var a;
  const s = n,
    o = e[t],
    i = null === (a = s.get(e)) || void 0 === a ? void 0 : a.get(r);
  if (void 0 !== i) return i;
  const u = o.p(
    r,
    (e, t) => innerValidate(e, t, n),
    (e, t) => innerValidateToPlaceholder(e, t, n),
  );
  return u.cycle ? (s.set(e, (s.get(e) || new Map()).set(r, u)), u) : u;
}
function innerSerialize(e, t, r) {
  const n = innerSerializeToPlaceholder(e, t, r);
  return n.cycle ? n.unwrap() : n;
}
function innerSerializeToPlaceholder(e, r, n) {
  var a;
  const s = n,
    o = e[t],
    i = null === (a = s.get(e)) || void 0 === a ? void 0 : a.get(r);
  if (void 0 !== i) return i;
  let u = (o.s || o.p)(
    r,
    (e, t) => innerSerialize(e, t, n),
    (e, t) => innerSerializeToPlaceholder(e, t, n),
  );
  return u.cycle ? (s.set(e, (s.get(e) || new Map()).set(r, u)), u) : u;
}
function innerGuard(e, r, n) {
  var a;
  const s = n,
    o = e[t];
  if (r && ("object" == typeof r || "function" == typeof r)) {
    if (null === (a = s.get(e)) || void 0 === a ? void 0 : a.has(r)) return;
    s.set(e, (s.get(e) || new Set()).add(r));
  }
  if (o.t) return o.t(r, (e, t) => innerGuard(e, t, n));
  let i = o.p(
    r,
    (e, t) => innerGuard(e, t, n) || success(t),
    (e, t) => innerGuard(e, t, n) || success(t),
  );
  return i.cycle && (i = i.unwrap()), i.success ? void 0 : i;
}
function showValue(e, r = 3, n = 30) {
  switch (typeof e) {
    case "bigint":
    case "boolean":
    case "number":
      return "" + e;
    case "string":
      return JSON.stringify(e);
    case "object":
      if (null === e) return "null";
      if (Array.isArray(e)) {
        if (0 === r || 0 === n) return "[Array]";
        {
          let t = "[",
            a = 0;
          for (a = 0; a < e.length && n > t.length; a++)
            0 !== a && (t += ", "), (t += showValue(e[a], r - 1, n - t.length));
          return a < e.length && (t += " ... "), (t += "]"), t;
        }
      }
      if ((e => "object" == typeof e && null != e && t in e)(e)) return e.toString();
      if (0 === r) return "{Object}";
      {
        const t = Object.entries(e);
        let a = "{",
          s = 0;
        for (s = 0; s < t.length && n > a.length; s++) {
          0 !== s && (a += ", ");
          const [e, o] = t[s];
          a += `${/\s/.test(e) ? JSON.stringify(e) : e}: ${showValue(o, r - 1, n - a.length)}`;
        }
        return s < t.length && (a += " ... "), (a += "}"), a;
      }
    case "function":
    case "symbol":
    case "undefined":
    default:
      return typeof e;
  }
}
function success(e) {
  return { success: !0, value: e };
}
function failure(e, t = {}) {
  return { success: !1, message: e, ...t };
}
function expected(e, t, r = {}) {
  return failure(`Expected ${"string" == typeof e ? e : show(e)}, but was ${showValue(t)}`, r);
}
function unableToAssign(e, t, ...r) {
  return [
    `Unable to assign ${showValue(e)} to ${"string" == typeof t ? t : show(t)}`,
    ...r.map(toFullError),
  ];
}
function andError([e, ...t]) {
  return [`And ${e[0].toLocaleLowerCase()}${e.substr(1)}`, ...t];
}
function typesAreNotCompatible(e, ...t) {
  return [`The types of ${e} are not compatible`, ...t.map(toFullError)];
}
function toFullError(e) {
  return "string" == typeof e ? [e] : Array.isArray(e) ? e : toFullError(e.fullError || e.message);
}
function showError(e) {
  return e.fullError ? showFullError(e.fullError) : e.key ? `${e.message} in ${e.key}` : e.message;
}
function showFullError([e, ...t], r = "") {
  return [`${r}${e}`, ...t.map(e => showFullError(e, r + "  "))].join("\n");
}
function AsyncContract(e, t) {
  return {
    enforce: r => (...n) => {
      if (n.length < e.length)
        return Promise.reject(
          new ValidationError({
            message: `Expected ${e.length} arguments but only received ${n.length}`,
          }),
        );
      const a = createVisitedState();
      for (let t = 0; t < e.length; t++) {
        const r = innerValidate(e[t], n[t], a);
        if (!r.success) return Promise.reject(new ValidationError(r));
        n[t] = r.value;
      }
      const s = r(...n);
      return s instanceof Promise
        ? s.then(e => {
            const r = innerGuard(t, e, createGuardVisitedState());
            if (r) throw new ValidationError(r);
            return e;
          })
        : Promise.reject(
            new ValidationError({
              message: "Expected function to return a promise, but instead got " + s,
            }),
          );
    },
  };
}
function Contract(e, t) {
  return {
    enforce: r => (...n) => {
      if (n.length < e.length)
        throw new ValidationError({
          message: `Expected ${e.length} arguments but only received ${n.length}`,
        });
      const a = createVisitedState();
      for (let t = 0; t < e.length; t++) {
        const r = innerValidate(e[t], n[t], a);
        if (!r.success) throw new ValidationError(r);
        n[t] = r.value;
      }
      const s = r(...n),
        o = innerGuard(t, s, createGuardVisitedState());
      if (o) throw new ValidationError(o);
      return s;
    },
  };
}
function assertType(e, t) {
  e.assert(t);
}
function InternalArr(e, t) {
  assertRuntype(e);
  const r = create(
    "array",
    (t, n) =>
      Array.isArray(t)
        ? createValidationPlaceholder([...t], a => {
            let s,
              o = void 0;
            for (let i = 0; i < t.length; i++) {
              const u = n(e, t[i]);
              u.success
                ? (a[i] = u.value)
                : (o || (o = unableToAssign(t, r)),
                  o.push(typesAreNotCompatible(`[${i}]`, u)),
                  (s =
                    s ||
                    failure(u.message, {
                      key: u.key ? `[${i}].${u.key}` : `[${i}]`,
                      fullError: o,
                    })));
            }
            return s;
          })
        : expected("an Array", t),
    {
      isReadonly: t,
      element: e,
      show() {
        return `${t ? "readonly " : ""}${show(e, !0)}[]`;
      },
    },
  );
  return t || (r.asReadonly = () => InternalArr(e, !0)), r;
}
function Arr(e) {
  return InternalArr(e, !1);
}
function ReadonlyArray(e) {
  return InternalArr(e, !0);
}
function Constraint(e, t, r) {
  assertRuntype(e);
  const n = create(
    "constraint",
    (a, s) => {
      const o = r && r.name,
        i = s(e, a);
      if (!i.success) return i;
      const u = t(i.value);
      if (!u || "string" == typeof u) {
        const e = "string" == typeof u ? u : `${showValue(a)} failed ${o || "constraint"} check`;
        return failure(e, { fullError: unableToAssign(a, n, e) });
      }
      return success(i.value);
    },
    {
      underlying: e,
      constraint: t,
      name: r && r.name,
      args: r && r.args,
      show(t) {
        return (r && r.name) || `WithConstraint<${show(e, t)}>`;
      },
    },
  );
  return n;
}
function Enum(e, t) {
  const r = Object.values(t),
    n = new Set(r.some(e => "number" == typeof e) ? r.filter(e => "number" == typeof e) : r);
  return create("enum", t => (n.has(t) ? success(t) : expected(e, t)), {
    enumObject: t,
    show: () => e,
  });
}
function InstanceOf(e) {
  return create("instanceof", t => (t instanceof e ? success(t) : expected("" + e.name, t)), {
    ctor: e,
    show() {
      return `InstanceOf<${e.name}>`;
    },
  });
}
function Intersect(...e) {
  return (
    assertRuntype(...e),
    create(
      "intersect",
      (t, r) => {
        if (Array.isArray(t))
          return createValidationPlaceholder([...t], t => {
            for (const n of e) {
              let e = r(n, t);
              if (!e.success) return e;
              if (!Array.isArray(e.value))
                return failure(
                  `The validator ${show(
                    n,
                  )} attempted to convert the type of this value from an array to something else. That conversion is not valid as the child of an intersect`,
                );
              t.splice(0, t.length, ...e.value);
            }
          });
        if (t && "object" == typeof t)
          return createValidationPlaceholder(Object.create(null), n => {
            for (const a of e) {
              let e = r(a, t);
              if (!e.success) return e;
              if (!e.value || "object" != typeof e.value)
                return failure(
                  `The validator ${show(
                    a,
                  )} attempted to convert the type of this value from an object to something else. That conversion is not valid as the child of an intersect`,
                );
              Object.assign(n, e.value);
            }
          });
        let n = t;
        for (const t of e) {
          let e = r(t, n);
          if (!e.success) return e;
          n = e.value;
        }
        return success(n);
      },
      {
        intersectees: e,
        show(t) {
          return parenthesize("" + e.map(e => show(e, !0)).join(" & "), t);
        },
      },
    )
  );
}
function KeyOf(e) {
  const t = new Set(Object.keys(e)),
    r = [...t]
      .sort()
      .map(e => showValue(e))
      .join(" | ");
  return create(
    "keyOf",
    e => (t.has("number" == typeof e ? e.toString() : e) ? success(e) : expected(r, e)),
    { keys: t, show: e => parenthesize(r, e) },
  );
}
function lazyValue(e) {
  let t;
  return () => t || (t = e());
}
function Lazy(e) {
  const t = lazyValue(e);
  return create("lazy", (e, r, n) => n(t(), e), {
    underlying: t,
    show(e) {
      return show(t(), e);
    },
  });
}
function Literal(e) {
  return create(
    "literal",
    t =>
      t === e
        ? success(t)
        : failure(
            `Expected literal ${showValue(e)}, but was ${showValue(t)}${
              typeof t != typeof e ? ` (i.e. a ${typeof t})` : ""
            }`,
          ),
    {
      value: e,
      show() {
        return showValue(e);
      },
    },
  );
}
function Named(e, t) {
  return (
    assertRuntype(t),
    create("named", (e, r) => r(t, e), {
      underlying: t,
      name: e,
      show() {
        return e;
      },
    })
  );
}
function hasKey(e, t) {
  return "object" == typeof t && e in t;
}
function InternalObject(e, t, r) {
  assertRuntype(...Object.values(e));
  const n = create(
    "object",
    (r, a) =>
      null == r || "object" != typeof r
        ? expected(n, r)
        : Array.isArray(r)
        ? failure(`Expected ${show(n)}, but was an Array`)
        : createValidationPlaceholder(Object.create(null), s => {
            let o,
              i = void 0;
            for (const u in e)
              if (!t || (hasKey(u, r) && void 0 !== r[u])) {
                const c = t || hasKey(u, r) ? r[u] : void 0;
                let l = a(e[u], c);
                l.success
                  ? (s[u] = l.value)
                  : (i || (i = unableToAssign(r, n)),
                    i.push(typesAreNotCompatible(`"${u}"`, l)),
                    (o =
                      o || failure(l.message, { key: l.key ? `${u}.${l.key}` : u, fullError: i })));
              }
            return o;
          }),
    {
      isPartial: t,
      isReadonly: r,
      fields: e,
      asPartial: () => InternalObject(n.fields, !0, n.isReadonly),
      asReadonly: () => InternalObject(n.fields, n.isPartial, !0),
      pick(...n) {
        const a = {};
        for (const t of n) a[t] = e[t];
        return InternalObject(a, t, r);
      },
      omit(...n) {
        const a = { ...e };
        for (const e of n) e in a && delete a[e];
        return InternalObject(a, t, r);
      },
      show() {
        const n = Object.keys(e);
        return n.length
          ? `{ ${n
              .map(n => `${r ? "readonly " : ""}${n}${t ? "?" : ""}: ${show(e[n], !1)};`)
              .join(" ")} }`
          : "{}";
      },
    },
  );
  return n;
}
function Obj(e) {
  return InternalObject(e, !1, !1);
}
function Partial(e) {
  return InternalObject(e, !0, !1);
}
function createPrimative(e) {
  return create(
    e,
    t =>
      typeof t === e
        ? success(t)
        : failure(
            `Expected ${e}, but was ${(e =>
              `${showValue(e)}${"string" == typeof e ? " (i.e. a string literal)" : ""}`)(t)}`,
          ),
    {},
  );
}
function Readonly(e) {
  const t = { ...e };
  t.isReadonly = !0;
  for (const r of ["asPartial", "pick", "omit"])
    "function" == typeof e[r] && (t[r] = (...t) => Readonly(e[r](...t)));
  return t;
}
function getExpectedBaseType(e) {
  switch (e.tag) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "literal":
      return typeof e.value;
    case "union":
      const t = e.alternatives.map(getExpectedBaseType);
      return t.reduce((e, t) => (e === t ? e : "mixed"), t[0]);
    case "constraint":
      return getExpectedBaseType(e.underlying);
  }
}
function Record(e, t) {
  assertRuntype(e, t);
  const r = lazyValue(() => getExpectedBaseType(e)),
    n = create(
      "record",
      (a, s) =>
        null == a || "object" != typeof a
          ? expected(n, a)
          : Object.getPrototypeOf(a) !== Object.prototype && null !== Object.getPrototypeOf(a)
          ? Array.isArray(a)
            ? failure("Expected Record, but was Array")
            : failure(`Expected ${show(n)}, but was ${Object.getPrototypeOf(a)}`)
          : createValidationPlaceholder(Object.create(null), n => {
              for (const o in a) {
                let i = null;
                if ("number" === r()) {
                  if (isNaN(+o)) return expected("record key to be a number", o);
                  i = s(e, +o);
                } else
                  "string" === r()
                    ? (i = s(e, o))
                    : ((i = s(e, o)), i.success || isNaN(+o) || (i = s(e, +o)));
                if (!i.success) return expected("record key to be " + show(e), o);
                const u = s(t, a[o]);
                if (!u.success) return failure(u.message, { key: u.key ? `${o}.${u.key}` : o });
                n[i.value] = u.value;
              }
            }),
      {
        key: e,
        value: t,
        isReadonly: !1,
        show() {
          return `{ [_: ${show(e, !1)}]: ${show(t, !1)} }`;
        },
      },
    );
  return n;
}
function Tuple(...e) {
  assertRuntype(...e);
  const t = create(
    "tuple",
    (r, n) =>
      Array.isArray(r)
        ? r.length !== e.length
          ? expected("an array of length " + e.length, r.length)
          : createValidationPlaceholder([...r], a => {
              let s,
                o = void 0;
              for (let i = 0; i < e.length; i++) {
                let u = n(e[i], r[i]);
                u.success
                  ? (a[i] = u.value)
                  : (o || (o = unableToAssign(r, t)),
                    o.push(typesAreNotCompatible(`[${i}]`, u)),
                    (s =
                      s ||
                      failure(u.message, {
                        key: u.key ? `[${i}].${u.key}` : `[${i}]`,
                        fullError: o,
                      })));
              }
              return s;
            })
        : expected("tuple to be an array", r),
    {
      components: e,
      isReadonly: !1,
      show() {
        return `[${e.map(e => show(e, !1)).join(", ")}]`;
      },
    },
  );
  return t;
}
function Brand(e, t) {
  return (
    assertRuntype(t),
    create("brand", (e, r, n) => n(t, e), {
      brand: e,
      entity: t,
      show(e) {
        return show(t, e);
      },
    })
  );
}
function isUnionType(e) {
  return "tag" in e && "union" === e.tag;
}
function resolveUnderlyingType(e, t) {
  return (e => "tag" in e && "lazy" === e.tag)(e)
    ? resolveUnderlyingType(e.underlying(), t)
    : (e => "tag" in e && "brand" === e.tag)(e)
    ? resolveUnderlyingType(e.entity, t)
    : (e => "tag" in e && "constraint" === e.tag)(e) ||
      (e => "tag" in e && "named" === e.tag)(e) ||
      ("p" === t && isParsedValueRuntype(e))
    ? resolveUnderlyingType(e.underlying, t)
    : "t" === t && isParsedValueRuntype(e)
    ? e.config.test
      ? resolveUnderlyingType(e.config.test, t)
      : s
    : "s" === t && isParsedValueRuntype(e)
    ? e.config.serialize
      ? e.config.test
        ? resolveUnderlyingType(e.config.test, t)
        : e
      : s
    : e;
}
function mapGet(e) {
  return (t, r) => {
    const n = e.get(t);
    if (void 0 !== n) return n;
    const a = r();
    return e.set(t, a), a;
  };
}
function findFields(e, t) {
  const r = resolveUnderlyingType(e, t),
    n = [],
    pushField = (e, r) => {
      const a = resolveUnderlyingType(r, t);
      if (isUnionType(a)) for (const t of a.alternatives) pushField(e, t);
      else n.push([e, a]);
    };
  if ("tag" in (a = r) && "object" === a.tag && !r.isPartial)
    for (const e of Object.keys(r.fields)) pushField(e, r.fields[e]);
  var a;
  if (
    ((e => "tag" in e && "tuple" === e.tag)(r) &&
      r.components.forEach((e, t) => {
        pushField("" + t, e);
      }),
    (e => "tag" in e && "intersect" === e.tag)(r))
  )
    for (const e of r.intersectees) n.push(...findFields(e, t));
  return n;
}
function Union(...e) {
  function validateWithKey(e, t) {
    const r =
      "" +
      Array.from(t.values())
        .map(e => show(e, !0))
        .join(" | ");
    return (n, a) => {
      if (!n || "object" != typeof n) return expected(r, n);
      const s = t.get(n[e]);
      if (s) {
        const t = a(s, n);
        return t.success
          ? t
          : failure(t.message, {
              key: `<${/^\d+$/.test(e) ? `[${e}]` : e}: ${showValue(n[e])}>${
                t.key ? "." + t.key : ""
              }`,
              fullError: unableToAssign(n, r, t),
            });
      }
      {
        const a = expected(
          Array.from(t.keys())
            .map(e => ("string" == typeof e ? `'${e}'` : e))
            .join(" | "),
          n[e],
          { key: /^\d+$/.test(e) ? `[${e}]` : e },
        );
        return (
          (a.fullError = unableToAssign(
            n,
            r,
            typesAreNotCompatible(/^\d+$/.test(e) ? `[${e}]` : `"${e}"`, a.message),
          )),
          a
        );
      }
    };
  }
  function validateWithoutKey(e) {
    return (t, r) => {
      let a;
      for (const s of e) {
        const e = r(s, t);
        if (e.success) return e;
        a
          ? a.push(andError(e.fullError || unableToAssign(t, s, e)))
          : (a = unableToAssign(t, n, e.fullError || unableToAssign(t, s, e)));
      }
      return expected(n, t, { fullError: a });
    };
  }
  assertRuntype(...e);
  const t = [];
  for (const r of e) isUnionType(r) ? t.push(...r.alternatives) : t.push(r);
  const validatorOf = e => {
      const r = t
          .filter(t => "never" !== resolveUnderlyingType(t, e).tag)
          .map(t => [t, findFields(t, e)]),
        n = r.filter(e => 0 !== e[1].length),
        a = r.filter(e => 0 === e[1].length),
        s = (e => {
          const t = (e => {
              const t = new Set(e[0]);
              for (const r of e) for (const e of t) r.has(e) || t.delete(e);
              return t;
            })(e.map(([, e]) => new Set(e.map(([e]) => e)))),
            r = new Map(["type", "kind", "tag", "version"].map(e => [e, new Map()]));
          for (const [a, s] of e)
            for (const [e, o] of s)
              if ("tag" in (n = o) && "literal" === n.tag) {
                const n = mapGet(r)(e, () => new Map());
                n.has(o.value) ? t.delete(e) : n.set(o.value, a);
              } else t.delete(e);
          var n;
          for (const [e, n] of r) if (t.has(e)) return [e, n];
        })(n);
      if (s && a.length) {
        const e = s && validateWithKey(s[0], s[1]),
          t = validateWithoutKey(a.map(e => e[0]));
        return (r, n) => {
          const a = e(r, n);
          if (a.success) return a;
          const s = t(r, n);
          return (
            s.success ||
              s.fullError.push(andError(a.fullError ? a.fullError : unableToAssign(r, "Object"))),
            s
          );
        };
      }
      return s ? validateWithKey(s[0], s[1]) : validateWithoutKey(t);
    },
    r = lazyValue(() => ({ p: validatorOf("p"), s: validatorOf("s"), t: validatorOf("t") })),
    n = create(
      "union",
      {
        p: (e, t) => r().p(e, t),
        s: (e, t) => r().s(e, t),
        t(e, t) {
          const n = r().s(e, (e, r) => t(e, r) || success(r));
          return n.success ? void 0 : n;
        },
      },
      {
        alternatives: t,
        match: (...t) => r => {
          const a = createVisitedState();
          for (let n = 0; n < e.length; n++) {
            const s = innerValidate(e[n], r, a);
            if (s.success) return t[n](s.value);
          }
          n.assert(r);
        },
        show(e) {
          return parenthesize("" + t.map(e => show(e, !0)).join(" | "), e);
        },
      },
    );
  return n;
}
const parenthesize = (e, t) => (t ? `(${e})` : e),
  e = new Set(),
  show = (t, r = !1) => {
    if (e.has(t) && "lazy" !== t.tag) return parenthesize("CIRCULAR " + t.tag, r);
    if (t.show) {
      e.add(t);
      try {
        return t.show(r);
      } finally {
        e.delete(t);
      }
    }
    return t.tag;
  },
  t = "__internal_runtype_methods__";
class ValidationError extends Error {
  constructor(e) {
    super(showError(e)),
      (this.name = "ValidationError"),
      (this.shortMessage = e.message),
      (this.key = e.key),
      (this.fullError = e.fullError);
  }
}
const r = create("unknown", e => success(e), {}),
  Guard = (e, t) => r.withGuard(e, t),
  n = Literal(void 0),
  a = Literal(null),
  s = create("never", e => expected("nothing", e), {}),
  o = createPrimative("boolean"),
  i = createPrimative("function"),
  u = createPrimative("number"),
  c = createPrimative("string"),
  l = createPrimative("symbol");
export {
  Arr as Array,
  AsyncContract,
  o as Boolean,
  Brand,
  Constraint,
  Contract,
  Enum,
  i as Function,
  Guard,
  InstanceOf,
  Intersect,
  KeyOf,
  Lazy,
  Literal,
  Named,
  s as Never,
  a as Null,
  u as Number,
  Obj as Object,
  ParsedValue,
  Partial,
  Readonly,
  ReadonlyArray,
  Record,
  c as String,
  l as Symbol,
  Tuple,
  n as Undefined,
  Union,
  r as Unknown,
  ValidationError,
  assertType,
  showError,
  show as showType,
  showValue,
};
