import sql, { SQLQuery, isSqlQuery } from '@databases/sql';
import Queryable, { Connection, ConnectionPool, Transaction } from './types/Queryable';
import EventHandlers from './types/EventHandlers';
export type { SQLQuery };
export { sql, isSqlQuery };
export type { Queryable, Transaction, Connection, ConnectionPool };
export interface ConnectionPoolConfig extends EventHandlers {
    /**
     * Should the `TINYINT` type be treated as a boolean or a number?
     *
     * MySQL doesn't have a true boolean type, so when you create a column
     * of type `BOOLEAN` or `BOOL` you actually get a column of type
     * `TINYINT(1)`. It is possible to use this to store other numbers
     * (in the range 0-255).
     *
     * If you use `boolean` mode, all values other than "0" are interpreted
     * as `true`, and "0" is interpreted as `false`. This matches the behaviour
     * of MySQL queries that use `value IS TRUE` or `value IS NOT TRUE`.
     *
     * See https://www.mysqltutorial.org/mysql-boolean/ for details.
     */
    tinyIntMode?: 'boolean' | 'number';
    /**
     * How would you like bigints to be returned from the database?
     *
     * If you choose `number` you may get inexact values for numbers greater than Number.MAX_SAFE_INTEGER
     *
     * Currently defaults to 'number', but this may change in a future version
     */
    bigIntMode?: 'string' | 'number' | 'bigint';
    /**
     * How would you like `DATE` types to be returned from the database?
     *
     * If you choose 'date-object' it will be a JavaScript `Date` that is
     * midnight in the client `timeZone`.
     *
     * Currently this defaults to `'date-object'` but the default will
     * change to `'string'` in a future version.
     */
    dateMode?: 'string' | 'date-object';
    /**
     * How would you like `DATETIME` types to be returned from the database?
     *
     * If you choose 'date-object' it will be a JavaScript `Date`.
     * If you choose 'string' it will be a string in the MySQL format, i.e. "yyyy-mm-dd HH:MM:SS[.nnnnnn]" with no time zone
     *
     * Currently this defaults to `'date-object'`.
     */
    dateTimeMode?: 'string' | 'date-object';
    /**
     * How would you like `TIMESTAMP` types to be returned from the database?
     *
     * If you choose 'date-object' it will be a JavaScript `Date`.
     * If you choose 'string' it will be a string in the MySQL format, i.e. "yyyy-mm-dd HH:MM:SS[.nnnnnn]" with no time zone
     *
     * Currently this defaults to `'date-object'`.
     */
    timeStampMode?: 'string' | 'date-object';
    /**
     * Time zone to use when serializing and parsing
     */
    timeZone?: 'local' | 'utc' | {
        server?: 'local' | 'utc';
        client: 'local' | 'utc';
    };
    /**
     * Defaults to process.env.DATABASE_URL
     */
    connectionString?: string;
    /**
     * maximum number of clients the pool should contain
     * by default this is set to 10.
     */
    poolSize?: number;
    /**
     * Maximum times to use a single connection from a connection pool before
     * discarding it and requesting a fresh connection.
     * defaults to Infinity
     */
    maxUses?: number;
    /**
     * number of milliseconds a client must sit idle in the pool and not be checked out
     * before it is disconnected from the backend and discarded
     *
     * default is 30_000 (30 seconds) - set to 0 to disable auto-disconnection of idle clients
     */
    idleTimeoutMilliseconds?: number;
    /**
     * Number of milliseconds to wait for a connection from the connection pool.
     *
     * Defaults to 60 seconds
     */
    queueTimeoutMilliseconds?: number;
    /**
     * Number of milliseconds to wait for a lock on a connection/transaction. This is
     * helpful for catching cases where you have accidentally attempted to query a connection
     * within a transaction that is on that connection, or attempted to query an outer transaction
     * within a nested transaction.
     *
     * Defaults to 60 seconds
     */
    acquireLockTimeoutMilliseconds?: number;
    onError?: (err: Error) => void;
}
export default function createConnectionPool(connectionConfig?: string | ConnectionPoolConfig | undefined): ConnectionPool;
