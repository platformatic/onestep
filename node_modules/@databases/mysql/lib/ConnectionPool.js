"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const shared_1 = require("@databases/shared");
const sql_1 = require("@databases/sql");
const promise_1 = require("mysql2/promise");
const Connection_1 = require("./Connection");
const Transaction_1 = require("./Transaction");
const MySqlDriver_1 = require("./MySqlDriver");
const factories = {
    createTransaction(driver, transactionParentContext) {
        return new Transaction_1.default(driver, factories, transactionParentContext);
    },
    createConnection(driver) {
        return new Connection_1.default(driver, factories);
    },
};
const getConnectionPoolOptions = (srcConfig, poolOptions, handlers, onError, acquireLockTimeoutMilliseconds, serverTimeZone) => {
    return {
        ...poolOptions,
        openConnection: async (removeFromPool) => {
            const client = await (0, promise_1.createConnection)(srcConfig);
            const driver = new MySqlDriver_1.default(client, handlers, acquireLockTimeoutMilliseconds);
            try {
                if (serverTimeZone === 'utc') {
                    await driver.client.query(`SET time_zone = "+00:00";`);
                }
                else if (serverTimeZone === 'local') {
                    await driver.client.query(`SET time_zone = ?;`, [
                        Intl.DateTimeFormat().resolvedOptions().timeZone,
                    ]);
                }
            }
            catch (ex) {
                void driver.dispose();
                throw ex;
            }
            driver.onAddingToPool(removeFromPool, onError);
            if (handlers.onConnectionOpened) {
                handlers.onConnectionOpened();
            }
            return driver;
        },
        closeConnection: async (driver) => {
            try {
                await driver.dispose();
                if (handlers.onConnectionClosed) {
                    handlers.onConnectionClosed();
                }
            }
            catch (ex) {
                console.warn(ex.message);
            }
        },
        onActive(driver) {
            driver.onActive();
        },
        onIdle(driver) {
            driver.onIdle();
        },
    };
};
class ConnectionPool extends shared_1.BaseConnectionPool {
    constructor(srcConfig, poolOptions, handlers, onError, acquireLockTimeoutMilliseconds, serverTimeZone) {
        super(getConnectionPoolOptions(srcConfig, poolOptions, handlers, onError, acquireLockTimeoutMilliseconds, serverTimeZone), factories);
        this.sql = sql_1.default;
    }
    queryNodeStream(query, options = {}) {
        this._throwIfDisposed();
        const stream = new stream_1.PassThrough({
            objectMode: true,
        });
        this._pool
            .getConnection()
            .then(async (driver) => {
            let released = false;
            const connectionStream = driver.connection.queryNodeStream(query, options);
            return connectionStream
                .on('fields', (fields) => {
                stream.emit('fields', fields);
            })
                .on('error', (err) => {
                if (!released) {
                    released = true;
                    driver.dispose();
                }
                stream.emit('error', err);
            })
                .on('end', () => {
                if (!released) {
                    released = true;
                    driver.release();
                }
                stream.emit('end');
            })
                .pipe(stream);
        })
            .catch((ex) => stream.emit('error', ex));
        return stream;
    }
}
exports.default = ConnectionPool;
//# sourceMappingURL=ConnectionPool.js.map