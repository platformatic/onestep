"use strict";
/* tslint:disable:no-void-expression */
Object.defineProperty(exports, "__esModule", { value: true });
const escape_identifier_1 = require("@databases/escape-identifier");
const sql_1 = require("@databases/sql");
const push_to_async_iterable_1 = require("@databases/push-to-async-iterable");
const { codeFrameColumns } = require('@babel/code-frame');
const mysqlFormat = {
    escapeIdentifier: (str) => (0, escape_identifier_1.escapeMySqlIdentifier)(str),
    formatValue: (value) => ({ placeholder: '?', value }),
};
class MySqlDriver {
    constructor(client, handlers, acquireLockTimeoutMilliseconds) {
        this._endCalled = false;
        this._onIdleError = (err) => {
            if (this._endCalled) {
                return;
            }
            this.client.removeListener('error', this._onIdleError);
            if (this._removeFromPool) {
                this._removeFromPool();
            }
            if (this._idleErrorEventHandler) {
                this._idleErrorEventHandler(err);
            }
        };
        this.acquireLockTimeoutMilliseconds = acquireLockTimeoutMilliseconds;
        this.client = client;
        this._handlers = handlers;
    }
    onAddingToPool(removeFromPool, idleErrorEventHandler) {
        this._removeFromPool = removeFromPool;
        this._idleErrorEventHandler = idleErrorEventHandler;
    }
    onActive() {
        this.client.removeListener('error', this._onIdleError);
    }
    onIdle() {
        this.client.on('error', this._onIdleError);
    }
    async dispose() {
        if (!this._endCalled) {
            this._endCalled = true;
            this.client.on('error', this._onIdleError);
            this.client.destroy();
        }
    }
    async canRecycleConnectionAfterError(_err) {
        var _a, _b, _c;
        try {
            let timeout;
            const result = await Promise.race([
                this.client.query('BEGIN TRANSACTION READ ONLY;SELECT 1 AS result;COMMIT;'),
                new Promise((r) => {
                    timeout = setTimeout(r, 100);
                }),
            ]);
            if (timeout !== undefined) {
                clearTimeout(timeout);
            }
            return ((_c = (_b = (_a = result === null || result === void 0 ? void 0 : result[1]) === null || _a === void 0 ? void 0 : _a.rows) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.result) === 1;
        }
        catch (ex) {
            return false;
        }
    }
    async beginTransaction(options) {
        const parameters = [];
        if (options) {
            if (options.readOnly) {
                parameters.push('READ ONLY');
            }
            else if (options.readOnly === false) {
                parameters.push('READ WRITE');
            }
            if (options.withConsistentSnapshot) {
                parameters.push('WITH CONSISTENT SNAPSHOT');
            }
        }
        if (parameters.length) {
            await execute(this.client, `START TRANSACTION ${parameters.join(', ')}`);
        }
        else {
            await execute(this.client, `BEGIN`);
        }
    }
    async commitTransaction() {
        await execute(this.client, `COMMIT`);
    }
    async rollbackTransaction() {
        await execute(this.client, `ROLLBACK`);
    }
    async shouldRetryTransactionFailure(_transactionOptions, _ex, _failureCount) {
        return false;
    }
    async createSavepoint(savepointName) {
        await execute(this.client, `SAVEPOINT ${savepointName}`);
    }
    async releaseSavepoint(savepointName) {
        await execute(this.client, `RELEASE SAVEPOINT ${savepointName}`);
    }
    async rollbackToSavepoint(savepointName) {
        await execute(this.client, `ROLLBACK TO SAVEPOINT ${savepointName}`);
    }
    async _executeQuery(query) {
        const q = query.format(mysqlFormat);
        if (this._handlers.onQueryStart) {
            enforceUndefined(this._handlers.onQueryStart(query, q));
        }
        const results = await executeQueryInternal(this.client, query, q, this._handlers);
        if (this._handlers.onQueryResults) {
            enforceUndefined(this._handlers.onQueryResults(query, q, results));
        }
        return results;
    }
    async executeAndReturnAll(queries) {
        const results = new Array(queries.length);
        for (let i = 0; i < queries.length; i++) {
            results[i] = await this._executeQuery(queries[i]);
        }
        return results;
    }
    async executeAndReturnLast(queries) {
        if (queries.length === 0) {
            return [];
        }
        for (let i = 0; i < queries.length - 1; i++) {
            await this._executeQuery(queries[i]);
        }
        return await this._executeQuery(queries[queries.length - 1]);
    }
    queryStream(query, options) {
        if (!(0, sql_1.isSqlQuery)(query)) {
            throw new Error('Invalid query, you must use @databases/sql to create your queries.');
        }
        const { text, values } = query.format(mysqlFormat);
        const highWaterMark = (options && options.highWaterMark) || 5;
        const connection = this.client.connection;
        return (0, push_to_async_iterable_1.default)((handlers) => {
            const stream = connection.query(text, values);
            stream.on('result', handlers.onData);
            stream.on('error', handlers.onError);
            stream.on('end', handlers.onEnd);
            return {
                dispose: () => {
                    connection.resume();
                },
                pause: () => {
                    connection.pause();
                },
                resume: () => {
                    connection.resume();
                },
                highWaterMark,
            };
        });
    }
    queryNodeStream(query, options) {
        if (!(0, sql_1.isSqlQuery)(query)) {
            throw new Error('Invalid query, you must use @databases/sql to create your queries.');
        }
        const { text, values } = query.format(mysqlFormat);
        const connection = this.client.connection;
        const result = connection.query(text, values).stream(options);
        // tslint:disable-next-line:no-unbound-method
        const on = result.on;
        const handlers = this._handlers;
        return Object.assign(result, {
            on(event, cb) {
                if (event !== 'error')
                    return on.call(this, event, cb);
                return on.call(this, event, (ex) => {
                    // TODO: consider using https://github.com/Vincit/db-errors
                    try {
                        handleError(ex, query, { text, values }, handlers);
                    }
                    catch (ex) {
                        cb(ex);
                    }
                });
            },
        });
    }
}
exports.default = MySqlDriver;
async function execute(client, query) {
    try {
        await client.query(query);
    }
    catch (ex) {
        throw Object.assign(new Error(ex.message), ex);
    }
}
async function executeQueryInternal(client, query, q, handlers) {
    try {
        // const result: [RowDataPacket[] | RowDataPacket[][] | OkPacket | OkPacket[] | ResultSetHeader, FieldPacket[]]
        const [result] = await client.query(q.text, q.values);
        return result;
    }
    catch (ex) {
        handleError(ex, query, q, handlers);
    }
}
function handleError(ex, query, q, handlers) {
    let err;
    const mySqlError = parseMySqlError(ex, q.text);
    if (mySqlError) {
        const { start, end, message: oldMessage } = mySqlError;
        const message = oldMessage.replace(/ near \'((?:.|\n)+)\' at line (\d+)$/, ` near:\n\n${codeFrameColumns(q.text, { start, end })}\n`);
        err = Object.assign(new Error(message), ex, { message });
    }
    else {
        err = Object.assign(new Error(isError(ex) ? ex.message : `${ex}`), ex);
    }
    if (handlers.onQueryError) {
        enforceUndefined(handlers.onQueryError(query, q, err));
    }
    throw err;
}
function parseMySqlError(ex, queryText) {
    if (isMySqlError(ex)) {
        const match = / near \'((?:.|\n)+)\' at line (\d+)$/.exec(ex.sqlMessage);
        if (match) {
            const index = queryText.indexOf(match[1]);
            if (index === queryText.lastIndexOf(match[1])) {
                const linesUptoStart = queryText.substr(0, index).split('\n');
                const line = linesUptoStart.length;
                const start = {
                    line,
                    column: linesUptoStart[linesUptoStart.length - 1].length + 1,
                };
                const linesUptoEnd = queryText
                    .substr(0, index + match[1].length)
                    .split('\n');
                const end = {
                    line: linesUptoEnd.length,
                    column: linesUptoEnd[linesUptoEnd.length - 1].length + 1,
                };
                return { start, end, message: ex.message };
            }
        }
    }
    return null;
}
function isError(ex) {
    return (typeof ex === 'object' &&
        ex !== null &&
        'message' in ex &&
        typeof ex.message === 'string');
}
function isMySqlError(ex) {
    return (typeof ex === 'object' &&
        ex !== null &&
        ex.code === 'ER_PARSE_ERROR' &&
        ex.sqlState === '42000' &&
        typeof ex.sqlMessage === 'string' &&
        typeof ex.message === 'string');
}
function enforceUndefined(value) {
    if (value !== undefined) {
        throw new Error(`Your event handlers must return "undefined". This is to allow for the possibility of event handlers being used as hooks with more advanced functionality in the future.`);
    }
}
//# sourceMappingURL=MySqlDriver.js.map