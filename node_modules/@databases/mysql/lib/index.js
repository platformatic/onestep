"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSqlQuery = exports.sql = void 0;
const url_1 = require("url");
const mysql_config_1 = require("@databases/mysql-config");
const sql_1 = require("@databases/sql");
exports.sql = sql_1.default;
Object.defineProperty(exports, "isSqlQuery", { enumerable: true, get: function () { return sql_1.isSqlQuery; } });
const ConnectionPool_1 = require("./ConnectionPool");
const { connectionStringEnvironmentVariable } = (0, mysql_config_1.getMySqlConfigSync)();
function createConnectionPool(connectionConfig = process.env[connectionStringEnvironmentVariable]) {
    const connectionConfigObject = typeof connectionConfig === 'object'
        ? connectionConfig
        : { connectionString: connectionConfig };
    const { connectionString = process.env[connectionStringEnvironmentVariable] } = connectionConfigObject;
    if (!connectionString) {
        throw new Error('You must provide a connection string for @databases/mysql. You can ' +
            'either pass one directly to the createConnection call or set ' +
            `the ${connectionStringEnvironmentVariable} environment variable.`);
    }
    validateMySqlUrl(connectionString);
    const { tinyIntMode = 'number', bigIntMode = 'number', dateMode = 'date-object', dateTimeMode = 'date-object', timeStampMode = 'date-object', timeZone = { client: 'local' }, poolSize = 10, maxUses = Infinity, idleTimeoutMilliseconds = 30000, queueTimeoutMilliseconds = 60000, acquireLockTimeoutMilliseconds = 60000, onConnectionClosed, onConnectionOpened, onQueryStart, onQueryResults, onQueryError, onError = (err) => {
        console.warn(`Error in MySQL ConnectionPool: ${err.message}`);
    }, } = connectionConfigObject;
    const serverTimeZone = typeof timeZone === 'string' ? timeZone : timeZone.server;
    const clientTimeZone = typeof timeZone === 'string' ? timeZone : timeZone.client;
    const tinyIntParser = getTinyIntParser(tinyIntMode);
    const bigIntParser = getBigIntParser(bigIntMode);
    const dateParer = getDateParser(dateMode, clientTimeZone);
    const dateTimeParser = getDateTimeParser(dateTimeMode, clientTimeZone);
    const timeStampParser = getDateTimeParser(timeStampMode, clientTimeZone);
    return new ConnectionPool_1.default({
        uri: connectionString,
        multipleStatements: true,
        timezone: clientTimeZone === 'utc' ? 'Z' : clientTimeZone,
        typeCast: (field, next) => {
            switch (field.type) {
                case 'TINY':
                    return tinyIntParser(field);
                case 'LONGLONG':
                    return bigIntParser(field);
                case 'DATE':
                    return dateParer(field);
                case 'DATETIME':
                    return dateTimeParser(field);
                case 'TIMESTAMP':
                    return timeStampParser(field);
            }
            return next();
        },
    }, {
        maxSize: poolSize,
        maxUses,
        idleTimeoutMilliseconds,
        queueTimeoutMilliseconds,
    }, {
        onConnectionClosed,
        onConnectionOpened,
        onQueryStart,
        onQueryResults,
        onQueryError,
    }, onError, acquireLockTimeoutMilliseconds, serverTimeZone);
}
exports.default = createConnectionPool;
function validateMySqlUrl(urlString) {
    let url;
    try {
        url = new url_1.URL(urlString);
    }
    catch (ex) {
        throw new Error('Invalid MySQL connection string, expected a URI: ' + urlString);
    }
    if (url.protocol !== 'mysqlx:' && url.protocol !== 'mysql:') {
        throw new Error('Invalid MySQL connection string, expected protocol to be "mysql" or "mysqlx": ' +
            urlString);
    }
}
function getTinyIntParser(mode) {
    switch (mode) {
        case 'number':
            return (f) => parseInt(f.string(), 10);
        case 'boolean':
            return (f) => f.string() !== '0';
    }
}
function getBigIntParser(mode) {
    switch (mode) {
        case 'number':
            return (f) => parseInt(f.string(), 10);
        case 'string':
            return (f) => f.string();
        case 'bigint':
            return (f) => BigInt(f.string());
    }
}
function getDateParser(mode, timeZone) {
    switch (mode) {
        case 'string':
            return (f) => f.string();
        case 'date-object':
            return (f) => {
                const match = /^(\d{4})\-(\d{2})\-(\d{2})$/.exec(f.string());
                if (!match) {
                    throw new Error('Expected yyyy-mm-dd');
                }
                if (timeZone === 'utc') {
                    return new Date(Date.UTC(parseInt(match[1], 10), parseInt(match[2], 10) - 1, parseInt(match[3], 10), 0, 0, 0, 0));
                }
                else {
                    return new Date(parseInt(match[1], 10), parseInt(match[2], 10) - 1, parseInt(match[3], 10), 0, 0, 0, 0);
                }
            };
    }
}
function getDateTimeParser(mode, timeZone) {
    switch (mode) {
        case 'string':
            return (f) => f.string();
        case 'date-object':
            return (f) => {
                var _a, _b;
                const fBuffer = f.buffer();
                if (fBuffer === null || fBuffer.length === 0) {
                    return null;
                }
                const match = /^(\d{4})\-(\d{2})\-(\d{2}) (\d{2})\:(\d{2})\:(\d{2})(?:\.(\d+))?$/.exec(fBuffer.toString());
                if (!match) {
                    throw new Error('Expected yyyy-mm-dd HH:MM:SS');
                }
                let ms = match[7]
                    ? parseInt(match[7].length > 3 ? match[7].substr(0, 3) : match[7], 10)
                    : 0;
                if (((_a = match[7]) === null || _a === void 0 ? void 0 : _a.length) === 2) {
                    ms = ms * 10;
                }
                if (((_b = match[7]) === null || _b === void 0 ? void 0 : _b.length) === 1) {
                    ms = ms * 100;
                }
                if (timeZone === 'utc') {
                    return new Date(Date.UTC(parseInt(match[1], 10), parseInt(match[2], 10) - 1, parseInt(match[3], 10), parseInt(match[4], 10), // hours
                    parseInt(match[5], 10), // minutes
                    parseInt(match[6], 10), // seconds
                    ms));
                }
                else {
                    return new Date(parseInt(match[1], 10), parseInt(match[2], 10) - 1, parseInt(match[3], 10), parseInt(match[4], 10), // hours
                    parseInt(match[5], 10), // minutes
                    parseInt(match[6], 10), // seconds
                    ms);
                }
            };
    }
}
module.exports = Object.assign(createConnectionPool, {
    default: createConnectionPool,
    sql: sql_1.default,
    isSqlQuery: sql_1.isSqlQuery,
});
//# sourceMappingURL=index.js.map