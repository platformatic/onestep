"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
jest.setTimeout(30000);
const db = (0, __1.default)();
afterAll(async () => {
    await db.dispose();
});
const allValues = [];
beforeAll(async () => {
    await db.query((0, __1.sql) `CREATE TABLE streaming_test_values (id BIGINT NOT NULL PRIMARY KEY);`);
    for (let batch = 0; batch < 10; batch++) {
        const batchValues = [];
        for (let i = 0; i < 1000; i++) {
            const value = batch * 1000 + i;
            batchValues.push(value);
            allValues.push(value);
        }
        await db.query((0, __1.sql) `
      INSERT INTO streaming_test_values (id)
      VALUES ${__1.sql.join(batchValues.map((v) => (0, __1.sql) `(${v})`), (0, __1.sql) `,`)};
    `);
    }
});
test('node streaming', async () => {
    const results = await new Promise((resolve, reject) => {
        const results = [];
        db.queryNodeStream((0, __1.sql) `SELECT * FROM streaming_test_values`, {
            highWaterMark: 1,
        })
            .on('data', (data) => results.push(data.id))
            .on('error', reject)
            .on('end', () => resolve(results));
    });
    expect(results).toEqual(allValues);
});
test('await streaming', async () => {
    const results = [];
    for await (const { id } of db.queryStream((0, __1.sql) `SELECT * FROM streaming_test_values`, {
        highWaterMark: 1,
    })) {
        results.push(id);
    }
    expect(results).toEqual(allValues);
});
//# sourceMappingURL=stream.test.mysql.js.map