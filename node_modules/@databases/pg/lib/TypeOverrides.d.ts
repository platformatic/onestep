/// <reference types="node" />
import PgDataTypeID from '@databases/pg-data-type-id';
import PgClient from './types/PgClient';
export declare type ParseFnText = (value: string) => any;
export declare type ParseFnBinary = (value: Buffer) => any;
export declare type TypeOverridesFunction = (ctx: {
    getTypeParser(oid: number, format?: 'text'): ParseFnText;
    getTypeParser(type: string, format?: 'text'): Promise<ParseFnText>;
    getTypeParser(oid: number, format: 'binary'): ParseFnBinary;
    getTypeParser(type: string, format: 'binary'): Promise<ParseFnBinary>;
    setTypeParser(oid: number, parseFn: ParseFnText): void;
    setTypeParser(oid: string, parseFn: ParseFnText): Promise<void>;
    setTypeParser(oid: number, format: 'text', parseFn: ParseFnText): void;
    setTypeParser(oid: string, format: 'text', parseFn: ParseFnText): Promise<void>;
    setTypeParser(oid: number, format: 'binary', parseFn: ParseFnBinary): void;
    setTypeParser(oid: string, format: 'binary', parseFn: ParseFnBinary): Promise<void>;
    parseComposite: typeof parseComposite;
    parseArray: typeof parseArray;
}) => undefined | TypeOverridesMap | TypeOverridesObject | Promise<undefined | TypeOverridesMap | TypeOverridesObject>;
export declare type TypeOverridesMap = {
    forEach(callbackfn: (value: ParseFnText | [number | PgDataTypeID, ParseFnText], key: number | PgDataTypeID) => void): void;
};
export declare type TypeOverridesObject = {
    [key in number | PgDataTypeID]?: ParseFnText;
};
export interface TypeOverridesConfig {
    bigIntMode: 'string' | 'number' | 'bigint';
    overrides?: TypeOverridesFunction | TypeOverridesMap | TypeOverridesObject;
}
export default class TypeOverrides {
    private readonly _overrides;
    private readonly _complexOverrides;
    constructor(config: TypeOverridesConfig);
    prepareOverrides(resolveTypeID: (typeName: string) => Promise<number>): Promise<void>;
    setTypeParser(oid: number, parseFn: ParseFnText): void;
    setTypeParser(oid: number, format: 'text', parseFn: ParseFnText): void;
    setTypeParser(oid: number, format: 'binary', parseFn: ParseFnBinary): void;
    getTypeParser(oid: number, format?: 'text'): ParseFnText;
    getTypeParser(oid: number, format: 'binary'): ParseFnBinary;
    getTypeParser(oid: number, format: 'text' | 'binary' | undefined): ParseFnText | ParseFnBinary;
}
/**
 * Parse a composite value and get a tuple of strings where
 * each string represents one attribute.
 *
 * @param value The raw string.
 */
export declare function parseComposite(value: string): string[];
export declare function parseArray<T>(value: string, entryParser: (entry: string | null) => T): T[];
export declare function parseArray<T>(value: string): (string | null)[];
export declare function getTypeResolver(client: PgClient): (typeName: string) => Promise<number>;
