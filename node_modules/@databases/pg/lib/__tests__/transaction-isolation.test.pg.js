"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
jest.setTimeout(30000);
const db = (0, __1.default)({
    bigIntMode: 'number',
    schema: 'transaction_isolation_test',
});
afterAll(async () => {
    await db.dispose();
});
function createSynchronizer() {
    const promises = [];
    const queue = () => {
        let resolve;
        promises.push(new Promise((r) => {
            resolve = r;
        }));
        return async () => {
            resolve();
            await Promise.all(promises);
        };
    };
    return [queue(), queue()];
}
async function transaction(db, { from, to, wait }) {
    const [{ sum }] = await db.query((0, __1.sql) `SELECT SUM(value) as sum FROM mytab WHERE class = ${from};`);
    await wait();
    await db.query((0, __1.sql) `INSERT INTO mytab (class, value) VALUES (${to}, ${sum})`);
}
async function prepare() {
    await db.query((0, __1.sql) `CREATE SCHEMA IF NOT EXISTS transaction_isolation_test`);
    await db.query((0, __1.sql) `DROP TABLE IF EXISTS mytab;`);
    await db.query((0, __1.sql) `CREATE TABLE mytab (
      id SERIAL NOT NULL PRIMARY KEY,
      class INT NOT NULL,
      value INT NOT NULL
    );`);
    await db.query((0, __1.sql) `
    INSERT INTO mytab (class, value)
    VALUES (1, 10),
           (1, 20),
           (2, 100),
           (2, 200);
  `);
}
async function results() {
    return await db.query((0, __1.sql) `
    SELECT class, value FROM mytab ORDER BY value ASC, class ASC
  `);
}
test('default isolation level', async () => {
    await prepare();
    const [waitA, waitB] = createSynchronizer();
    await Promise.all([
        db.tx(async (tx) => await transaction(tx, { from: 1, to: 2, wait: waitA })),
        db.tx(async (tx) => await transaction(tx, { from: 2, to: 1, wait: waitB })),
    ]);
    await expect(results()).resolves.toMatchInlineSnapshot(`
          Array [
            Object {
              "class": 1,
              "value": 10,
            },
            Object {
              "class": 1,
              "value": 20,
            },
            Object {
              "class": 2,
              "value": 30,
            },
            Object {
              "class": 2,
              "value": 100,
            },
            Object {
              "class": 2,
              "value": 200,
            },
            Object {
              "class": 1,
              "value": 300,
            },
          ]
        `);
});
test('serializable', async () => {
    await prepare();
    const [waitA, waitB] = createSynchronizer();
    await expect(Promise.all([
        db.tx(async (tx) => await transaction(tx, { from: 1, to: 2, wait: waitA }), {
            isolationLevel: __1.IsolationLevel.SERIALIZABLE,
        }),
        db.tx(async (tx) => await transaction(tx, { from: 2, to: 1, wait: waitB }), {
            isolationLevel: __1.IsolationLevel.SERIALIZABLE,
        }),
    ])).rejects.toMatchInlineSnapshot(`[error: could not serialize access due to read/write dependencies among transactions]`);
});
test('serializable - with retry', async () => {
    await prepare();
    const [waitA, waitB] = createSynchronizer();
    let attempts = 0;
    await Promise.all([
        db.tx(async (tx) => {
            attempts++;
            await transaction(tx, { from: 1, to: 2, wait: waitA });
        }, {
            isolationLevel: __1.IsolationLevel.SERIALIZABLE,
            retrySerializationFailures: true,
        }),
        db.tx(async (tx) => {
            attempts++;
            await transaction(tx, { from: 2, to: 1, wait: waitB });
        }, {
            isolationLevel: __1.IsolationLevel.SERIALIZABLE,
            retrySerializationFailures: true,
        }),
    ]);
    expect(attempts).toBe(3);
    expect([
        [
            {
                class: 1,
                value: 10,
            },
            {
                class: 1,
                value: 20,
            },
            {
                class: 2,
                value: 30,
            },
            {
                class: 2,
                value: 100,
            },
            {
                class: 2,
                value: 200,
            },
            {
                class: 1,
                value: 330,
            },
        ],
        [
            {
                class: 1,
                value: 10,
            },
            {
                class: 1,
                value: 20,
            },
            {
                class: 2,
                value: 100,
            },
            {
                class: 2,
                value: 200,
            },
            {
                class: 1,
                value: 300,
            },
            {
                class: 2,
                value: 330,
            },
        ],
    ]).toContainEqual(await results());
});
//# sourceMappingURL=transaction-isolation.test.pg.js.map