"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeResolver = exports.parseArray = exports.parseComposite = void 0;
const pg_data_type_id_1 = require("@databases/pg-data-type-id");
const { types } = require('pg');
function isTypeOverridesMap(value) {
    return (value !== null &&
        typeof value === 'object' &&
        typeof value.forEach === 'function');
}
class TypeOverrides {
    constructor(config) {
        this._overrides = {
            text: new Map(),
            binary: new Map(),
        };
        if (config.bigIntMode === 'bigint') {
            this._overrides.binary.set(pg_data_type_id_1.default.int8, (value) => value.readBigInt64BE(0));
            this._overrides.text.set(pg_data_type_id_1.default.int8, (value) => BigInt(value));
        }
        else if (config.bigIntMode === 'number') {
            this._overrides.binary.set(pg_data_type_id_1.default.int8, (value) => parseInt(value.readBigInt64BE(0).toString(10), 10));
            this._overrides.text.set(pg_data_type_id_1.default.int8, (value) => parseInt(value, 10));
        }
        this._complexOverrides = config.overrides;
    }
    async prepareOverrides(resolveTypeID) {
        let overrides;
        if (typeof this._complexOverrides === 'function') {
            overrides = await this._complexOverrides({
                getTypeParser: (type, ...rest) => {
                    if (typeof type === 'number') {
                        return this.getTypeParser(type, ...rest);
                    }
                    else {
                        return resolveTypeID(type).then((id) => this.getTypeParser(id, ...rest));
                    }
                },
                setTypeParser: (type, ...rest) => {
                    if (typeof type === 'number') {
                        this.setTypeParser(type, ...rest);
                    }
                    else {
                        return resolveTypeID(type).then((id) => this.setTypeParser(id, ...rest));
                    }
                },
                parseComposite,
                parseArray,
            });
        }
        else {
            overrides = this._complexOverrides;
        }
        if (isTypeOverridesMap(overrides)) {
            overrides.forEach((value, key) => {
                if (Array.isArray(value)) {
                    this._overrides.text.set(value[0], value[1]);
                }
                else {
                    this._overrides.text.set(key, value);
                }
            });
        }
        else if (overrides && typeof overrides === 'object') {
            for (const [key, value] of Object.entries(overrides)) {
                if (value)
                    this._overrides.text.set(parseInt(key, 10), value);
            }
        }
    }
    setTypeParser(oid, ...rest) {
        const [a, b] = rest;
        const [format, parseFn] = typeof a === 'function' ? ['text', a] : [a, b];
        this._overrides[format].set(oid, parseFn);
    }
    getTypeParser(oid, format = 'text') {
        var _a;
        return (_a = this._overrides[format].get(oid)) !== null && _a !== void 0 ? _a : types.getTypeParser(oid, format);
    }
}
exports.default = TypeOverrides;
/**
 * Parse a composite value and get a tuple of strings where
 * each string represents one attribute.
 *
 * @param value The raw string.
 */
function parseComposite(value) {
    if (value[0] !== '(') {
        throw new Error('composite values should start with (');
    }
    const values = [];
    let currentValue = '';
    let quoted = false;
    for (let i = 1; i < value.length; i++) {
        if (!quoted && value[i] === ',') {
            values.push(currentValue);
            currentValue = '';
            continue;
        }
        else if (!quoted && value[i] === ')') {
            values.push(currentValue);
            currentValue = '';
            if (i !== value.length - 1) {
                throw new Error('Got ")" before end of value');
            }
            continue;
        }
        else if (quoted && value[i] === '"') {
            if (value[i + 1] === '"') {
                // if the next value is also a quote, that means we
                // are looking at an escaped quote. Skip this char
                // and insert the quote
                i++;
            }
            else {
                quoted = false;
                continue;
            }
        }
        else if (value[i] === '"') {
            quoted = true;
            continue;
        }
        currentValue += value[i];
    }
    if (currentValue) {
        throw new Error('Got to end of value with no ")"');
    }
    return values;
}
exports.parseComposite = parseComposite;
const parseStringArray = types.getTypeParser(pg_data_type_id_1.default._text);
function parseArray(value, entryParser) {
    if (entryParser) {
        return parseStringArray(value).map(entryParser);
    }
    else {
        return parseStringArray(value);
    }
}
exports.parseArray = parseArray;
function getTypeResolver(client) {
    return async (typeName) => {
        const ts = typeName.split('.');
        let results;
        if (ts.length === 1) {
            results = (await client.query(`
          SELECT
            ty.oid as "typeID",
            ns.nspname AS "schemaName"
          FROM pg_catalog.pg_type ty
          INNER JOIN pg_catalog.pg_namespace ns
            ON (ty.typnamespace = ns.oid)
          WHERE lower(ty.typname) = $1;
        `, [typeName.toLowerCase()]));
        }
        else if (ts.length === 2) {
            results = (await client.query(`
          SELECT
            ty.oid as "typeID",
            ns.nspname AS "schemaName"
          FROM pg_catalog.pg_type ty
          INNER JOIN pg_catalog.pg_namespace ns
            ON (ty.typnamespace = ns.oid)
          WHERE lower(ns.nspname) = $1 AND lower(ty.typname) = $2;
        `, [ts[0].toLowerCase(), ts[1].toLowerCase()]));
        }
        else {
            throw new Error('Type Name should only have one "." in it');
        }
        if (results.rows.length === 0) {
            throw new Error('Could not find the type ' + typeName);
        }
        if (results.rows.length > 1) {
            throw new Error('The type name ' +
                typeName +
                ' was found in multiple schemas: ' +
                results.rows.map((r) => r.schemaName).join(', '));
        }
        return results.rows[0].typeID;
    };
}
exports.getTypeResolver = getTypeResolver;
//# sourceMappingURL=TypeOverrides.js.map