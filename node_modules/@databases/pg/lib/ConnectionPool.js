"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@databases/shared");
const sql_1 = require("@databases/sql");
const escape_identifier_1 = require("@databases/escape-identifier");
const Connection_1 = require("./Connection");
const Transaction_1 = require("./Transaction");
const stream_1 = require("stream");
const TypeOverrides_1 = require("./TypeOverrides");
const ConnectionSource_1 = require("./ConnectionSource");
const definePrecondition_1 = require("./definePrecondition");
const pg_errors_1 = require("@databases/pg-errors");
const factories = {
    createTransaction(driver, transactionParentContext) {
        return new Transaction_1.default(driver, factories, transactionParentContext);
    },
    createConnection(driver) {
        return new Connection_1.default(driver, factories);
    },
};
const getConnectionPoolOptions = (srcConfig, schema, poolOptions, handlers, onError, acquireLockTimeoutMilliseconds) => {
    const src = (0, ConnectionSource_1.default)(srcConfig, handlers, acquireLockTimeoutMilliseconds);
    // setting up types requires a connection, but doesn't have to be done separately for each connection,
    // doing it once is sufficient
    const typesSetup = (0, definePrecondition_1.default)(async (client) => {
        return srcConfig.types.prepareOverrides((0, TypeOverrides_1.getTypeResolver)(client));
    });
    return {
        ...poolOptions,
        isConnectionLimitError: (err) => {
            if (err.code === pg_errors_1.SQLErrorCode.TOO_MANY_CONNECTIONS) {
                onError(err);
                return true;
            }
            return false;
        },
        openConnection: async (removeFromPool) => {
            const driver = await src();
            try {
                await typesSetup.callPrecondition(driver.client);
                if (schema) {
                    // the schema (i.e. the search_path) must be set on each connection before it is used
                    if (typeof schema === 'string') {
                        await driver.client.query(`SET search_path TO ${(0, escape_identifier_1.escapePostgresIdentifier)(schema)}`);
                    }
                    else if (Array.isArray(schema)) {
                        await driver.client.query(`SET search_path TO ${schema
                            .map((s) => (0, escape_identifier_1.escapePostgresIdentifier)(s))
                            .join(', ')}`);
                    }
                }
            }
            catch (ex) {
                await driver.dispose().catch(() => {
                    // ignore error within error
                });
                throw ex;
            }
            driver.onAddingToPool(removeFromPool, onError);
            if (handlers.onConnectionOpened) {
                handlers.onConnectionOpened();
            }
            return driver;
        },
        closeConnection: async (driver) => {
            try {
                await driver.dispose();
                if (handlers.onConnectionClosed) {
                    handlers.onConnectionClosed();
                }
            }
            catch (ex) {
                console.warn(ex.message);
            }
        },
        onActive(driver) {
            driver.onActive();
        },
        onIdle(driver) {
            driver.onIdle();
        },
    };
};
class ConnectionPool extends shared_1.BaseConnectionPool {
    constructor(options, { poolOptions = {}, schema, handlers: { onError, ...handlers }, acquireLockTimeoutMilliseconds, }) {
        super(getConnectionPoolOptions(options, schema, poolOptions, handlers, onError, acquireLockTimeoutMilliseconds), factories);
        this.sql = sql_1.default;
        this.parseComposite = TypeOverrides_1.parseComposite;
        this.parseArray = TypeOverrides_1.parseArray;
        this._types = options.types;
    }
    async registerTypeParser(type, parser) {
        if (typeof type === 'number') {
            this._types.setTypeParser(type, parser);
        }
        else {
            const driver = await this._pool.getConnection();
            let released = false;
            try {
                const id = await (0, TypeOverrides_1.getTypeResolver)(driver.connection.client)(type);
                driver.release();
                released = true;
                this._types.setTypeParser(id, parser);
            }
            finally {
                if (!released) {
                    driver.dispose();
                }
            }
        }
        return parser;
    }
    async getTypeParser(type) {
        if (typeof type === 'number') {
            return this._types.getTypeParser(type);
        }
        else {
            const driver = await this._pool.getConnection();
            let released = false;
            try {
                const id = await (0, TypeOverrides_1.getTypeResolver)(driver.connection.client)(type);
                driver.release();
                released = true;
                return this._types.getTypeParser(id);
            }
            finally {
                if (!released) {
                    driver.dispose();
                }
            }
        }
    }
    queryNodeStream(query, options = {}) {
        this._throwIfDisposed();
        const stream = new stream_1.PassThrough({
            objectMode: true,
        });
        this._pool
            .getConnection()
            .then(async (driver) => {
            let released = false;
            const connectionStream = driver.connection.queryNodeStream(query, options);
            connectionStream.pipe(stream);
            connectionStream.on('error', () => {
                if (!released) {
                    released = true;
                    driver.dispose();
                }
                stream.emit('error', stream);
            });
            connectionStream.on('close', () => {
                if (!released) {
                    released = true;
                    driver.release();
                }
                stream.emit('close');
            });
            stream.on('close', () => {
                connectionStream.destroy();
            });
        })
            .catch((ex) => stream.emit('error', ex));
        return stream;
    }
}
exports.default = ConnectionPool;
//# sourceMappingURL=ConnectionPool.js.map