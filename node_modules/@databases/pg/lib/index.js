"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConnectionPool = exports.isConnection = exports.isTransaction = exports.IsolationLevel = exports.QueryableType = exports.DataTypeID = exports.SQLErrorCode = exports.isSQLError = exports.isSqlQuery = exports.sql = exports.pgFormat = void 0;
const fs_1 = require("fs");
const shared_1 = require("@databases/shared");
Object.defineProperty(exports, "QueryableType", { enumerable: true, get: function () { return shared_1.QueryableType; } });
const pg_connection_string_1 = require("@databases/pg-connection-string");
const pg_data_type_id_1 = require("@databases/pg-data-type-id");
exports.DataTypeID = pg_data_type_id_1.default;
const pg_errors_1 = require("@databases/pg-errors");
Object.defineProperty(exports, "isSQLError", { enumerable: true, get: function () { return pg_errors_1.isSQLError; } });
Object.defineProperty(exports, "SQLErrorCode", { enumerable: true, get: function () { return pg_errors_1.SQLErrorCode; } });
const sql_1 = require("@databases/sql");
exports.sql = sql_1.default;
Object.defineProperty(exports, "isSqlQuery", { enumerable: true, get: function () { return sql_1.isSqlQuery; } });
const pg_config_1 = require("@databases/pg-config");
const ConnectionPool_1 = require("./ConnectionPool");
const IsolationLevel_1 = require("./types/IsolationLevel");
exports.IsolationLevel = IsolationLevel_1.default;
const Queryable_1 = require("./types/Queryable");
Object.defineProperty(exports, "isTransaction", { enumerable: true, get: function () { return Queryable_1.isTransaction; } });
Object.defineProperty(exports, "isConnection", { enumerable: true, get: function () { return Queryable_1.isConnection; } });
Object.defineProperty(exports, "isConnectionPool", { enumerable: true, get: function () { return Queryable_1.isConnectionPool; } });
const TypeOverrides_1 = require("./TypeOverrides");
const format_1 = require("./format");
exports.pgFormat = format_1.default;
const { connectionStringEnvironmentVariable } = (0, pg_config_1.getPgConfigSync)();
function createConnectionPool(connectionConfig = process.env[connectionStringEnvironmentVariable]) {
    var _a;
    const { connectionString = process.env[connectionStringEnvironmentVariable] } = typeof connectionConfig === 'object'
        ? connectionConfig
        : { connectionString: connectionConfig };
    const parsedConnectionString = (0, pg_connection_string_1.default)(connectionString || undefined);
    const connectionConfigObject = typeof connectionConfig === 'object' ? connectionConfig : {};
    const { user = parsedConnectionString.user, password = parsedConnectionString.password, host = parsedConnectionString.host, database = parsedConnectionString.dbname, port = parsedConnectionString.port, connectionTimeoutMilliseconds = 10000, idleTimeoutMilliseconds = 30000, poolSize = 10, statementTimeoutMilliseconds = 0, queryTimeoutMilliseconds = 0, idleInTransactionSessionTimeoutMilliseconds = 0, queueTimeoutMilliseconds = Math.max(60000, ((_a = connectionConfigObject.connectionTimeoutMilliseconds) !== null && _a !== void 0 ? _a : 10000) *
        (Array.isArray(host)
            ? host.length
            : host === undefined
                ? 1
                : parsedConnectionString.host.length
                    ? parsedConnectionString.host.length
                    : 1) *
        2), acquireLockTimeoutMilliseconds = 60000, applicationName = parsedConnectionString.application_name, keepAlive = false, keepAliveInitialDelayMilliseconds = 0, maxUses = Infinity, bigIntMode = null, 
    // tslint:disable-next-line:deprecation
    bigIntAsString = false, schema, types: typeOverrides, onError = (err) => {
        // It's common for connections to be terminated "unexpectedly"
        // If it happens on a connection that is actively in use, you'll get the error
        // anyway when you attempt to query it. If it happens on a connection that is
        // idle in the pool, a fresh connection will be allocated without you needing
        // to do anything.
        if (!/connection\s*terminated\s*unexpectedly/i.test(err.message)) {
            console.warn(`Error in Postgres ConnectionPool: ${err.message}`);
        }
    }, onQueryError, onQueryResults, onQueryStart, onConnectionOpened, onConnectionClosed, } = connectionConfigObject;
    if (!connectionConfig &&
        ![user, password, host, database].some((v) => v !== undefined && !(Array.isArray(v) && v.length === 0))) {
        throw new Error('You must provide a connection string for @databases/pg. You can ' +
            'either pass one directly to the createConnection call or set ' +
            `the ${connectionStringEnvironmentVariable} environment variable.`);
    }
    if (bigIntAsString) {
        console.warn('bigIntAsString is deprecated and will be removed in the next major version of @databases/pg, use `bigIntMode: "string"` instead');
    }
    else if (bigIntMode === null) {
        console.warn('bigIntMode currently defaults to "number" but will default to "bigint" in the next major version of @databases/pg. Set it explicitly to disable this warning.');
    }
    const types = new TypeOverrides_1.default({
        bigIntMode: bigIntMode !== null && bigIntMode !== void 0 ? bigIntMode : (bigIntAsString ? 'string' : 'number'),
        overrides: typeOverrides,
    });
    const sslConfig = getSSLConfig(typeof connectionConfig === 'object' ? connectionConfig : {}, parsedConnectionString);
    const hostList = Array.isArray(host) ? host : [host];
    const portList = Array.isArray(port) ? port : [port];
    if (portList.length > 1 && hostList.length !== portList.length) {
        throw new Error('If you provide more than port, you must provide exactly the same number of hosts and port');
    }
    const pgOptions = {
        user,
        password,
        database,
        connectionTimeoutMillis: connectionTimeoutMilliseconds,
        ...(statementTimeoutMilliseconds
            ? { statement_timeout: statementTimeoutMilliseconds }
            : {}),
        ...(queryTimeoutMilliseconds
            ? { query_timeout: queryTimeoutMilliseconds }
            : {}),
        ...(idleInTransactionSessionTimeoutMilliseconds
            ? {
                idle_in_transaction_session_timeout: idleInTransactionSessionTimeoutMilliseconds,
            }
            : {}),
        application_name: applicationName ||
            (typeof connectionConfig === 'object' ? connectionConfig : {})
                .fallbackApplicationName ||
            parsedConnectionString.fallback_application_name,
        keepAlive,
        keepAliveInitialDelayMillis: keepAliveInitialDelayMilliseconds,
        types,
        hosts: (hostList.length === 0 ? ['localhost'] : hostList).map((host, i) => {
            const port = portList.length === 0
                ? undefined
                : portList.length === 1
                    ? portList[0]
                    : portList[i];
            return {
                host,
                port: port !== null && port !== void 0 ? port : undefined,
            };
        }),
        ssl: sslConfig,
    };
    return new ConnectionPool_1.default(pgOptions, {
        poolOptions: {
            maxSize: poolSize,
            maxUses,
            idleTimeoutMilliseconds,
            queueTimeoutMilliseconds,
            // releaseTimeoutMilliseconds: 1000,
        },
        schema,
        handlers: {
            onError,
            onQueryStart,
            onQueryResults,
            onQueryError,
            onConnectionOpened,
            onConnectionClosed,
        },
        acquireLockTimeoutMilliseconds: acquireLockTimeoutMilliseconds === 0
            ? Infinity
            : acquireLockTimeoutMilliseconds,
    });
}
exports.default = createConnectionPool;
function getSSLConfig(config, parsedConnectionString) {
    if (config.ssl === false ||
        config.ssl === 'disable' ||
        (!config.ssl && parsedConnectionString.sslmode === 'disable')) {
        return null;
    }
    if (config.ssl && typeof config.ssl === 'object') {
        return { allowFallback: false, connectionOptions: config.ssl };
    }
    const ssl = {};
    if (parsedConnectionString.sslcert) {
        ssl.cert = (0, fs_1.readFileSync)(parsedConnectionString.sslcert, 'utf8');
    }
    if (parsedConnectionString.sslkey) {
        ssl.key = (0, fs_1.readFileSync)(parsedConnectionString.sslkey, 'utf8');
    }
    if (parsedConnectionString.sslrootcert) {
        ssl.ca = (0, fs_1.readFileSync)(parsedConnectionString.sslrootcert, 'utf8');
    }
    if (config.ssl === 'no-verify' ||
        (!config.ssl && parsedConnectionString.sslmode === 'no-verify') ||
        !(parsedConnectionString.sslcert ||
            parsedConnectionString.sslkey ||
            parsedConnectionString.sslrootcert)) {
        ssl.rejectUnauthorized = false;
    }
    const mode = config.ssl || parsedConnectionString.sslmode;
    if (mode === 'prefer' || mode === undefined) {
        ssl.rejectUnauthorized = false;
        return { allowFallback: true, connectionOptions: ssl };
    }
    else {
        return { allowFallback: false, connectionOptions: ssl };
    }
}
module.exports = Object.assign(createConnectionPool, {
    default: createConnectionPool,
    pgFormat: format_1.default,
    sql: sql_1.default,
    isSqlQuery: sql_1.isSqlQuery,
    isSQLError: pg_errors_1.isSQLError,
    SQLErrorCode: pg_errors_1.SQLErrorCode,
    DataTypeID: pg_data_type_id_1.default,
    IsolationLevel: IsolationLevel_1.default,
    QueryableType: shared_1.QueryableType,
    isTransaction: Queryable_1.isTransaction,
    isConnection: Queryable_1.isConnection,
    isConnectionPool: Queryable_1.isConnectionPool,
});
//# sourceMappingURL=index.js.map