"use strict";
/* tslint:disable:no-void-expression */
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const pg_errors_1 = require("@databases/pg-errors");
const sql_1 = require("@databases/sql");
const IsolationLevel_1 = require("./types/IsolationLevel");
const format_1 = require("./format");
const { codeFrameColumns } = require('@babel/code-frame');
const Cursor = require('pg-cursor');
const RECOVERABLE_ERRORS = new Set([
    pg_errors_1.SQLErrorCode.INTEGRITY_CONSTRAINT_VIOLATION,
    pg_errors_1.SQLErrorCode.RESTRICT_VIOLATION,
    pg_errors_1.SQLErrorCode.NOT_NULL_VIOLATION,
    pg_errors_1.SQLErrorCode.FOREIGN_KEY_VIOLATION,
    pg_errors_1.SQLErrorCode.UNIQUE_VIOLATION,
    pg_errors_1.SQLErrorCode.CHECK_VIOLATION,
    pg_errors_1.SQLErrorCode.EXCLUSION_VIOLATION,
]);
function isRecoverableError(err) {
    return (0, pg_errors_1.isSQLError)(err) && RECOVERABLE_ERRORS.has(err.code);
}
class PgDriver {
    constructor(client, handlers, acquireLockTimeoutMilliseconds) {
        this._endCalled = false;
        this._canRecycleConnection = true;
        this._isIdle = false;
        this._idleError = null;
        this._onIdleError = (err) => {
            if (this._endCalled)
                return;
            this._canRecycleConnection = false;
            if (this._isIdle) {
                if (this._idleErrorEventHandler) {
                    this._idleErrorEventHandler(err);
                }
            }
            else {
                this._idleError = err;
            }
            if (this._removeFromPool) {
                this._removeFromPool();
            }
        };
        this.acquireLockTimeoutMilliseconds = acquireLockTimeoutMilliseconds;
        client.on('error', this._onIdleError);
        this._disposed = new Promise((resolve) => {
            client.on('end', resolve);
        });
        this.client = client;
        this._handlers = handlers;
    }
    _throwPendingIdleError() {
        if (this._idleError) {
            const err = this._idleError;
            this._idleError = null;
            throw err;
        }
    }
    onAddingToPool(removeFromPool, idleErrorEventHandler) {
        this._removeFromPool = removeFromPool;
        this._idleErrorEventHandler = idleErrorEventHandler;
    }
    onActive() {
        this._isIdle = false;
    }
    onIdle() {
        this._isIdle = true;
    }
    async connect() {
        return await this.client.connect();
    }
    async dispose() {
        var _a, _b;
        if (!this._endCalled) {
            this._endCalled = true;
            if ((_b = (_a = this.client.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.destroy) {
                this.client.connection.stream.destroy();
            }
            else {
                void this.client.end();
            }
        }
        return await this._disposed;
    }
    async canRecycleConnectionAfterError(_err) {
        return this._canRecycleConnection;
    }
    async beginTransaction(options) {
        try {
            this._throwPendingIdleError();
            const parameters = [];
            if (options) {
                if (options.isolationLevel) {
                    parameters.push((0, IsolationLevel_1.isolationLevelToString)(options.isolationLevel));
                }
                if (options.readOnly) {
                    parameters.push('READ ONLY');
                }
                else if (options.readOnly === false) {
                    parameters.push('READ WRITE');
                }
                if (options.deferrable) {
                    parameters.push('DEFERRABLE');
                }
                else if (options.deferrable === false) {
                    parameters.push('NOT DEFERRABLE');
                }
            }
            if (parameters.length) {
                await execute(this.client, `BEGIN ${parameters.join(', ')}`);
            }
            else {
                await execute(this.client, `BEGIN`);
            }
        }
        catch (ex) {
            this._canRecycleConnection = false;
            throw ex;
        }
    }
    async commitTransaction() {
        try {
            this._throwPendingIdleError();
            await execute(this.client, `COMMIT`);
        }
        catch (ex) {
            if (!isRecoverableError(ex)) {
                this._canRecycleConnection = false;
            }
            // Make sure we report a decent stack trace
            const err = Object.assign(new Error(isError(ex) ? ex.message : `${ex}`), ex);
            throw err;
        }
    }
    async rollbackTransaction() {
        try {
            this._throwPendingIdleError();
            await execute(this.client, `ROLLBACK`);
        }
        catch (ex) {
            this._canRecycleConnection = false;
            throw ex;
        }
    }
    async shouldRetryTransactionFailure(transactionOptions, ex, failureCount) {
        const retrySerializationFailuresCount = !transactionOptions
            ? 0
            : transactionOptions.retrySerializationFailures === true
                ? 10
                : typeof transactionOptions.retrySerializationFailures === 'number'
                    ? transactionOptions.retrySerializationFailures
                    : 0;
        if ((0, pg_errors_1.isSQLError)(ex) && ex.code === pg_errors_1.SQLErrorCode.SERIALIZATION_FAILURE) {
            if (retrySerializationFailuresCount > failureCount) {
                await new Promise((resolve) => setTimeout(resolve, Math.max(10, Math.floor(Math.random() * 100 * failureCount))));
                return true;
            }
        }
        return false;
    }
    async createSavepoint(savepointName) {
        try {
            this._throwPendingIdleError();
            await execute(this.client, `SAVEPOINT ${savepointName}`);
        }
        catch (ex) {
            this._canRecycleConnection = false;
            throw ex;
        }
    }
    async releaseSavepoint(savepointName) {
        try {
            this._throwPendingIdleError();
            await execute(this.client, `RELEASE SAVEPOINT ${savepointName}`);
        }
        catch (ex) {
            this._canRecycleConnection = false;
            throw ex;
        }
    }
    async rollbackToSavepoint(savepointName) {
        try {
            this._throwPendingIdleError();
            await execute(this.client, `ROLLBACK TO SAVEPOINT ${savepointName}`);
        }
        catch (ex) {
            this._canRecycleConnection = false;
            throw ex;
        }
    }
    async _executeQuery(query) {
        try {
            this._throwPendingIdleError();
            const q = query.format(format_1.default);
            if (this._handlers.onQueryStart) {
                enforceUndefined(this._handlers.onQueryStart(query, q));
            }
            const results = await executeQueryInternal(this.client, query, q, this._handlers);
            if (this._handlers.onQueryResults) {
                enforceUndefined(this._handlers.onQueryResults(query, q, results.rows));
            }
            return results.rows;
        }
        catch (ex) {
            if (!isRecoverableError(ex)) {
                this._canRecycleConnection = false;
            }
            throw ex;
        }
    }
    async executeAndReturnAll(queries) {
        const results = new Array(queries.length);
        for (let i = 0; i < queries.length; i++) {
            results[i] = await this._executeQuery(queries[i]);
        }
        return results;
    }
    async executeAndReturnLast(queries) {
        if (queries.length === 0) {
            return [];
        }
        for (let i = 0; i < queries.length - 1; i++) {
            await this._executeQuery(queries[i]);
        }
        return await this._executeQuery(queries[queries.length - 1]);
    }
    queryNodeStream(query, options) {
        this._throwPendingIdleError();
        this._canRecycleConnection = false;
        if (!(0, sql_1.isSqlQuery)(query)) {
            throw new Error('Invalid query, you must use @databases/sql to create your queries.');
        }
        const q = query.format(format_1.default);
        const c = new Cursor(q.text, q.values);
        let closed = false;
        let reading = false;
        const stream = new stream_1.Readable({
            ...options,
            // defauâ€  to `false` in node 12 but true in node 14
            autoDestroy: true,
            objectMode: true,
            read(count) {
                if (reading)
                    return;
                reading = true;
                const read = () => {
                    c.read(count, (err, rows) => {
                        if (err) {
                            this.emit('error', err);
                            return;
                        }
                        if (!rows.length) {
                            closed = true;
                            this.push(null);
                            return;
                        }
                        let keepReading = true;
                        for (const row of rows) {
                            keepReading = keepReading && this.push(row);
                        }
                        if (keepReading) {
                            read();
                        }
                        else {
                            reading = false;
                        }
                    });
                };
                read();
            },
            destroy(err, callback) {
                if (closed) {
                    callback(err);
                    return;
                }
                closed = true;
                c.close((err2) => {
                    callback(err !== null && err !== void 0 ? err : err2);
                });
            },
        });
        void this.client.query(c);
        return stream;
    }
    async *queryStream(query, { batchSize = 16, signal } = {}) {
        this._throwPendingIdleError();
        this._canRecycleConnection = false;
        if (!(0, sql_1.isSqlQuery)(query)) {
            throw new Error('Invalid query, you must use @databases/sql to create your queries.');
        }
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('Aborted');
        }
        const q = query.format(format_1.default);
        const c = new Cursor(q.text, q.values);
        void this.client.query(c);
        const read = async () => {
            return await new Promise((resolve, reject) => {
                c.read(batchSize, (err, rows) => {
                    if (err)
                        reject(err);
                    else
                        resolve(rows);
                });
            });
        };
        let aborted = false;
        const abort = () => {
            if (aborted)
                return;
            aborted = true;
            c.close(() => {
                // ignore
            });
        };
        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', abort);
        try {
            let nextPagePromise;
            let ended = false;
            while (!ended) {
                const page = await (nextPagePromise !== null && nextPagePromise !== void 0 ? nextPagePromise : read());
                if (page.length !== 0) {
                    nextPagePromise = read();
                    nextPagePromise.catch((ex) => {
                        // this error gets picked up later, so don't report the unhandled rejection
                    });
                    ended = false;
                }
                else {
                    nextPagePromise = undefined;
                    ended = true;
                }
                for (const row of page) {
                    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                        throw new Error('Aborted');
                    }
                    yield row;
                }
            }
            aborted = true;
        }
        finally {
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', abort);
            abort();
        }
    }
}
exports.default = PgDriver;
async function execute(client, query) {
    try {
        await client.query(query);
    }
    catch (ex) {
        throw Object.assign(new Error(ex.message), ex);
    }
}
async function executeQueryInternal(client, query, q, handlers) {
    try {
        const result = (await client.query(q));
        if (Array.isArray(result)) {
            return result[result.length - 1];
        }
        else {
            return result;
        }
    }
    catch (ex) {
        handleError(ex, query, q, handlers);
    }
}
function handleError(ex, query, q, handlers) {
    let err;
    if ((0, pg_errors_1.isSQLError)(ex) && ex.position) {
        const position = parseInt(ex.position, 10);
        const match = /syntax error at or near \"([^\"\n]+)\"/.exec(ex.message) ||
            /relation \"([^\"\n]+)\" does not exist/.exec(ex.message);
        let column = 0;
        let line = 1;
        for (let i = 0; i < position; i++) {
            if (q.text[i] === '\n') {
                line++;
                column = 0;
            }
            else {
                column++;
            }
        }
        const start = { line, column };
        let end;
        if (match) {
            end = { line, column: column + match[1].length };
        }
        err = Object.assign(new Error(`${ex.message}\n\n${codeFrameColumns(q.text, { start, end })}\n`), ex);
    }
    else {
        err = Object.assign(new Error(isError(ex) ? ex.message : `${ex}`), ex);
    }
    if (handlers.onQueryError) {
        enforceUndefined(handlers.onQueryError(query, q, err));
    }
    throw err;
}
function isError(ex) {
    return (typeof ex === 'object' &&
        ex !== null &&
        'message' in ex &&
        typeof ex.message === 'string');
}
function enforceUndefined(value) {
    if (value !== undefined) {
        throw new Error(`Your event handlers must return "undefined". This is to allow for the possibility of event handlers being used as hooks with more advanced functionality in the future.`);
    }
}
//# sourceMappingURL=Driver.js.map