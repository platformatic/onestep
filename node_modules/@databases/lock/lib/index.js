"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocksByKey = exports.createLocksByKey = exports.getLock = exports.createLock = void 0;
const queue_1 = require("@databases/queue");
class FunctionCallTask {
    constructor(fn, args) {
        this.fn = fn;
        this.args = args;
    }
}
class QueueRecord {
    constructor(resolve, task) {
        this.isTimedOut = false;
        this.resolve = resolve;
        this.task = task;
        this.createdAt = Date.now();
    }
}
const lockPool = [];
class LockImpl {
    constructor(timeoutMilliseconds, onEmpty, context) {
        this._queue = new queue_1.default();
        this._active = true;
        this._executing = false;
        this._onFunctionCallTaskLock = async (task) => {
            try {
                return await task.fn(...task.args);
            }
            finally {
                this.releaseLock();
            }
        };
        this._onTimeout = () => {
            this._timeout = undefined;
            const record = this._queue.shift();
            if (record) {
                record.isTimedOut = true;
                record.resolve(record);
            }
        };
        this._runDelayed = (d) => {
            if (this._timeout) {
                clearTimeout(this._timeout);
                this._timeout = undefined;
            }
            const nextRecord = this._queue.peek();
            if (nextRecord && this._timeoutMilliseconds !== undefined) {
                this._timeout = setTimeout(this._onTimeout, this._timeoutMilliseconds + nextRecord.createdAt - Date.now());
            }
            if (d.isTimedOut) {
                this.releaseLock();
                throw new Error(`Timed out waiting for lock after ${this._timeoutMilliseconds}ms`);
            }
            return d.task;
        };
        this._timeoutMilliseconds =
            timeoutMilliseconds === Infinity ? undefined : timeoutMilliseconds;
        this._onEmpty = onEmpty;
        this._context = context;
    }
    unpool(timeoutMilliseconds, onEmpty, context) {
        this._timeoutMilliseconds =
            timeoutMilliseconds === Infinity ? undefined : timeoutMilliseconds;
        this._onEmpty = onEmpty;
        this._context = context;
        this._active = true;
        return this;
    }
    async pool() {
        await this.acquireLock();
        if (this._queue.getLength() !== 0) {
            throw new Error('Cannot pool the lock if it has tasks in the queue.');
        }
        this._onEmpty = undefined;
        this._context = undefined;
        this._active = false;
        this._executing = false;
        lockPool.push(this);
    }
    async acquireLock(task) {
        if (!this._active) {
            throw new Error('Cannot call Lock after returning the object to the pool.');
        }
        if (this._executing) {
            if (this._timeout === undefined &&
                this._timeoutMilliseconds !== undefined) {
                this._timeout = setTimeout(this._onTimeout, this._timeoutMilliseconds);
            }
            return new Promise((resolve) => {
                this._queue.push(new QueueRecord(resolve, task));
            }).then(this._runDelayed);
        }
        else {
            this._executing = true;
            return task;
        }
    }
    releaseLock() {
        const next = this._queue.shift();
        if (next) {
            next.resolve(next);
        }
        else {
            this._executing = false;
            if (this._onEmpty)
                this._onEmpty(this, this._context);
        }
    }
    async withLock(fn, ...args) {
        return await this.acquireLock(new FunctionCallTask(fn, args)).then(this._onFunctionCallTaskLock);
    }
}
function createLock(timeoutMilliseconds) {
    if (lockPool.length) {
        const record = lockPool.pop();
        return record.unpool(timeoutMilliseconds, undefined, undefined);
    }
    else {
        return new LockImpl(timeoutMilliseconds, undefined, undefined);
    }
}
exports.createLock = createLock;
/**
 * @deprecated use createLock
 */
exports.getLock = createLock;
function createLockForKey(timeoutMilliseconds, onEmpty, key) {
    if (lockPool.length) {
        const record = lockPool.pop();
        return record.unpool(timeoutMilliseconds, onEmpty, key);
    }
    else {
        return new LockImpl(timeoutMilliseconds, onEmpty, key);
    }
}
class LocksByKeyImpl {
    constructor(options) {
        var _a;
        this._onEmpty = (lock, key) => {
            this._store.delete(key);
            void lock.pool();
        };
        this._store = (_a = options.store) !== null && _a !== void 0 ? _a : new Map();
        this._timeoutMilliseconds = options.timeoutMilliseconds;
    }
    async acquireLock(key, task) {
        const existingLock = this._store.get(key);
        if (existingLock) {
            return await existingLock.acquireLock(task);
        }
        const newLock = createLockForKey(this._timeoutMilliseconds, this._onEmpty, key);
        this._store.set(key, newLock);
        return await newLock.acquireLock(task);
    }
    async withLock(key, fn, ...args) {
        const existingLock = this._store.get(key);
        if (existingLock) {
            return await existingLock.withLock(fn, ...args);
        }
        const newLock = createLockForKey(this._timeoutMilliseconds, this._onEmpty, key);
        this._store.set(key, newLock);
        return await newLock.withLock(fn, ...args);
    }
    releaseLock(key) {
        const existingLock = this._store.get(key);
        if (existingLock) {
            existingLock.releaseLock();
        }
    }
}
function createLocksByKey(options = {}) {
    return new LocksByKeyImpl(options);
}
exports.createLocksByKey = createLocksByKey;
/**
 * @deprecated use createLocksByKey
 */
exports.getLocksByKey = createLocksByKey;
//# sourceMappingURL=index.js.map