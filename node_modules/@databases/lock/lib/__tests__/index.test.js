"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const pending = ['pending'];
const fulfilled = (value) => ['fulfilled', value];
const rejected = (err) => ['rejected', err];
async function clearPromiseQueue() {
    for (let i = 0; i < 10; i++) {
        await new Promise((r) => r());
    }
}
async function delay(ms) {
    await new Promise((r) => setTimeout(r, ms));
}
function expectPromises(state) {
    return expect(state.test()).resolves;
}
function promisesState() {
    let running = false;
    let previousPromises = [];
    let newPromises = [];
    async function test() {
        expect(running).toBe(false);
        running = true;
        const promises = [...previousPromises, ...newPromises];
        previousPromises = [];
        newPromises = [];
        const results = promises.map(() => pending);
        for (let i = 0; i < promises.length; i++) {
            const index = i;
            promises[index].then((value) => {
                results[index] = fulfilled(value);
            }, (err) => {
                if (err instanceof Error) {
                    results[index] = rejected(err.message);
                }
                else {
                    results[index] = rejected('NON_ERROR');
                }
            });
        }
        await clearPromiseQueue();
        previousPromises = promises.filter((_, i) => results[i][0] === 'pending');
        running = false;
        return results.slice();
    }
    function push(...value) {
        newPromises.push(...value);
    }
    return { test, push };
}
test('lock with 20ms timeout', async () => {
    const lock = __1.createLock(20);
    const results = promisesState();
    results.push(lock.acquireLock(), lock.acquireLock(), lock.acquireLock());
    await expectPromises(results).toEqual([
        fulfilled(undefined),
        pending,
        pending,
    ]);
    lock.releaseLock();
    await expectPromises(results).toEqual([fulfilled(undefined), pending]);
    await delay(40);
    await expectPromises(results).toEqual([
        rejected('Timed out waiting for lock after 20ms'),
    ]);
    results.push(lock.acquireLock('hello world'));
    results.push(lock.pool());
    await expectPromises(results).toEqual([fulfilled('hello world'), pending]);
    await delay(40);
    await expectPromises(results).toEqual([
        rejected('Timed out waiting for lock after 20ms'),
    ]);
    results.push(lock.acquireLock());
    results.push(lock.pool());
    await expectPromises(results).toEqual([fulfilled(undefined), pending]);
    lock.releaseLock();
    await expectPromises(results).toEqual([fulfilled(undefined)]);
    results.push(lock.acquireLock());
    await expectPromises(results).toEqual([
        rejected('Cannot call Lock after returning the object to the pool.'),
    ]);
});
test('lock with no timeout', async () => {
    const lock = __1.createLock();
    const results = promisesState();
    results.push(lock.acquireLock(), lock.acquireLock(), lock.acquireLock());
    await expectPromises(results).toEqual([
        fulfilled(undefined),
        pending,
        pending,
    ]);
    lock.releaseLock();
    await expectPromises(results).toEqual([fulfilled(undefined), pending]);
    await delay(40);
    await expectPromises(results).toEqual([pending]);
    lock.releaseLock();
    await expectPromises(results).toEqual([fulfilled(undefined)]);
    lock.releaseLock();
    results.push(lock.acquireLock('hello world'));
    results.push(lock.pool());
    await expectPromises(results).toEqual([fulfilled('hello world'), pending]);
    await delay(40);
    await expectPromises(results).toEqual([pending]);
    lock.releaseLock();
    await expectPromises(results).toEqual([fulfilled(undefined)]);
    results.push(lock.acquireLock());
    await expectPromises(results).toEqual([
        rejected('Cannot call Lock after returning the object to the pool.'),
    ]);
});
test('locks by key', async () => {
    const lock = __1.createLocksByKey();
    const results = promisesState();
    results.push(lock.acquireLock('a'), lock.acquireLock('a'), lock.acquireLock('b'));
    await expectPromises(results).toEqual([
        fulfilled(undefined),
        pending,
        fulfilled(undefined),
    ]);
    lock.releaseLock('a');
    await expectPromises(results).toEqual([fulfilled(undefined)]);
    lock.releaseLock('a');
    lock.releaseLock('b');
    results.push(lock.acquireLock('a', 24), lock.acquireLock('b', 42));
    await expectPromises(results).toEqual([fulfilled(24), fulfilled(42)]);
    lock.releaseLock('a');
    lock.releaseLock('b');
});
//# sourceMappingURL=index.test.js.map