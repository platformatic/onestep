export interface Lock {
    /**
     * Acquire a lock, then call the function, and then release the
     * lock. The lock is released if the function successfully returns
     * or if the function throws an error.
     */
    withLock<TArgs extends any[], TResult>(fn: (...args: TArgs) => Promise<TResult> | TResult, ...args: TArgs): Promise<TResult>;
    /**
     * Request a lock. You must call `releaseLock` exaclty once
     * after calling `acquireLock`, otherwise the lock can end up
     * in an invalid state.
     */
    acquireLock(): Promise<void>;
    /**
     * Request a lock. You must call `releaseLock` exaclty once
     * after calling `acquireLock`, otherwise the lock can end up
     * in an invalid state.
     *
     * You can include the "Task" you wish to perform while the
     * lock is held, to avoid creating closures that can impact
     * performance.
     */
    acquireLock<T>(task: T): Promise<T>;
    /**
     * Release a lock. You MUST call this exactly once for each
     * successful response from acquireLock
     */
    releaseLock(): void;
    /**
     * Return this lock object to the pool of locks. Only call this
     * if you are not going to use this lock again. It is ok to
     * never call this, and allow the locks to simply be garbage
     * collected as normal.
     */
    pool(): Promise<void>;
}
export declare function createLock(timeoutMilliseconds?: number): Lock;
/**
 * @deprecated use createLock
 */
export declare const getLock: typeof createLock;
export interface LocksByKeyOptions<TKey = string> {
    store?: {
        get(key: TKey): undefined | Lock;
        set(key: TKey, lock: Lock): unknown;
        delete(key: TKey): unknown;
    };
    timeoutMilliseconds?: number;
}
export interface LocksByKey<TKey = string> {
    /**
     * Acquire a lock, then call the function, and then release the
     * lock. The lock is released if the function successfully returns
     * or if the function throws an error.
     */
    withLock<TArgs extends any[], TResult>(key: TKey, fn: (...args: TArgs) => Promise<TResult> | TResult, ...args: TArgs): Promise<TResult>;
    /**
     * Request a lock. You must call `releaseLock` exaclty once
     * after calling `acquireLock`, otherwise the lock can end up
     * in an invalid state.
     */
    acquireLock(key: TKey): Promise<void>;
    /**
     * Request a lock. You must call `releaseLock` exaclty once
     * after calling `acquireLock`, otherwise the lock can end up
     * in an invalid state.
     *
     * You can include the "Task" you wish to perform while the
     * lock is held, to avoid creating closures that can impact
     * performance.
     */
    acquireLock<T>(key: TKey, task: T): Promise<T>;
    /**
     * Release a lock. You MUST call this exactly once for each
     * successful response from acquireLock
     */
    releaseLock(key: TKey): void;
}
export declare function createLocksByKey<TKey = string>(options?: LocksByKeyOptions<TKey>): LocksByKey<TKey>;
/**
 * @deprecated use createLocksByKey
 */
export declare const getLocksByKey: typeof createLocksByKey;
