"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgConfigSchema = exports.TypesConfigSchema = exports.PgTypesPrimaryKeyTypeMode = exports.PgTypesEnumTypeMode = exports.PgTypesDomainTypeMode = exports.TestConfigSchema = void 0;
const ft = require("funtypes");
function withDefault(type, defaultValue) {
    return ft.Union(type, ft.Undefined.withParser({
        parse() {
            return { success: true, value: defaultValue };
        },
        name: `undefined`,
    }));
}
function integer({ min = -Math.pow(2, 31), max = Math.pow(2, 32), }) {
    return ft.Number.withConstraint((value) => {
        if (value !== Math.floor(value)) {
            return `Expected an integer but got ${value}`;
        }
        if (value < min || value > max) {
            return `Expected an integer between ${min} and ${max} but got ${value}`;
        }
        return true;
    }, { name: `Integer` });
}
exports.TestConfigSchema = ft
    .Object({
    debug: withDefault(ft.Boolean, false),
    migrationsScript: ft.Union(ft.String, ft.Array(ft.String), ft.Undefined),
    image: withDefault(ft.String, `postgres:10.6-alpine`),
    containerName: withDefault(ft.String, `pg-test`),
    connectTimeoutSeconds: withDefault(integer({ min: 0 }), 20),
    port: withDefault(integer({ min: 0, max: 65535 }), undefined),
    pgUser: withDefault(ft.String, `test-user`),
    pgDb: withDefault(ft.String, `test-db`),
})
    .withConstraint((value) => true, { name: `TestConfig` });
var PgTypesDomainTypeMode;
(function (PgTypesDomainTypeMode) {
    PgTypesDomainTypeMode["strict_brand"] = "strict_brand";
    PgTypesDomainTypeMode["loose_brand"] = "loose_brand";
    PgTypesDomainTypeMode["alias"] = "alias";
    PgTypesDomainTypeMode["inline"] = "inline";
})(PgTypesDomainTypeMode = exports.PgTypesDomainTypeMode || (exports.PgTypesDomainTypeMode = {}));
var PgTypesEnumTypeMode;
(function (PgTypesEnumTypeMode) {
    PgTypesEnumTypeMode["enum"] = "enum";
    PgTypesEnumTypeMode["union_alias"] = "union_alias";
    PgTypesEnumTypeMode["union_alias_with_object"] = "union_alias_with_object";
    PgTypesEnumTypeMode["inline"] = "inline";
})(PgTypesEnumTypeMode = exports.PgTypesEnumTypeMode || (exports.PgTypesEnumTypeMode = {}));
var PgTypesPrimaryKeyTypeMode;
(function (PgTypesPrimaryKeyTypeMode) {
    PgTypesPrimaryKeyTypeMode["strict_brand"] = "strict_brand";
    PgTypesPrimaryKeyTypeMode["loose_brand"] = "loose_brand";
    PgTypesPrimaryKeyTypeMode["inline_strict_brand"] = "inline_strict_brand";
    PgTypesPrimaryKeyTypeMode["inline_loose_brand"] = "inline_loose_brand";
    PgTypesPrimaryKeyTypeMode["inline_no_brand"] = "inline_no_brand";
})(PgTypesPrimaryKeyTypeMode = exports.PgTypesPrimaryKeyTypeMode || (exports.PgTypesPrimaryKeyTypeMode = {}));
exports.TypesConfigSchema = ft
    .Object({
    directory: withDefault(ft.String, `__generated__`),
    domainTypeMode: withDefault(ft.Enum(`PgTypesDomainTypeMode`, PgTypesDomainTypeMode), PgTypesDomainTypeMode.loose_brand),
    domainTypeName: withDefault(ft.String, `{{ TYPE_NAME | pascal-case }}`),
    domainFileName: withDefault(ft.String, `_custom_types.ts`),
    enumTypeMode: withDefault(ft.Enum(`PgTypesEnumTypeMode`, PgTypesEnumTypeMode), PgTypesEnumTypeMode.union_alias),
    enumTypeName: withDefault(ft.String, `{{ TYPE_NAME | pascal-case }}`),
    enumFileName: withDefault(ft.String, `_enums.ts`),
    primaryKeyTypeMode: withDefault(ft.Enum(`PgTypesPrimaryKeyTypeMode`, PgTypesPrimaryKeyTypeMode), PgTypesPrimaryKeyTypeMode.inline_loose_brand),
    primaryKeyTypeName: withDefault(ft.String, `{{ TABLE_NAME | pascal-case }}_{{ COLUMN_NAME | pascal-case }}`),
    primaryKeyFileName: withDefault(ft.String, `{{ TABLE_NAME }}.ts`),
    tableTypeName: withDefault(ft.String, `{{ TABLE_NAME | pascal-case }}`),
    tableFileName: withDefault(ft.String, `{{ TABLE_NAME }}.ts`),
    tableReExportFileName: withDefault(ft.Union(ft.String, ft.Null), 'index.ts'),
    tableInsertParametersTypeName: withDefault(ft.String, `{{ TABLE_NAME | pascal-case }}_InsertParameters`),
    tableInsertParametersFileName: withDefault(ft.String, `{{ TABLE_NAME }}.ts`),
    tableInsertParametersReExportFileName: withDefault(ft.Union(ft.String, ft.Null), 'index.ts'),
    schemaTypeName: withDefault(ft.String, `DatabaseSchema`),
    schemaFileName: withDefault(ft.String, `index.ts`),
    schemaJsonFileName: withDefault(ft.Union(ft.String, ft.Null), `schema.json`),
    serializeValueTypeName: withDefault(ft.String, `serializeValue`),
    serializeValueFileName: withDefault(ft.String, `index.ts`),
    columnTypeOverrides: withDefault(ft.Record(ft.String, ft.String), {}),
    typeOverrides: withDefault(ft.Record(ft.String, ft.String), {}),
    includeTables: withDefault(ft.Union(ft.Array(ft.String), ft.Null), null),
    ignoreTables: withDefault(ft.Array(ft.String), []),
})
    .withConstraint((value) => true, { name: `TypesConfig` });
exports.PgConfigSchema = ft.Object({
    connectionStringEnvironmentVariable: withDefault(ft.String, `DATABASE_URL`),
    migrationsDirectory: withDefault(ft.String, undefined),
    test: withDefault(exports.TestConfigSchema, exports.TestConfigSchema.parse({})),
    types: withDefault(exports.TypesConfigSchema, exports.TypesConfigSchema.parse({})),
});
//# sourceMappingURL=PgConfig.js.map