"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.txInternal = exports.taskInternal = exports.queryInternal = exports.executeAndReturnLast = exports.executeAndReturnAll = exports.assertSql = void 0;
const web_1 = require("@databases/sql/web");
function assertSql(query) {
    if (Array.isArray(query)) {
        for (const q of query) {
            if (!(0, web_1.isSqlQuery)(q)) {
                throw new Error('Invalid query, you must use @databases/sql to create your queries.');
            }
        }
    }
    else {
        if (!(0, web_1.isSqlQuery)(query)) {
            throw new Error('Invalid query, you must use @databases/sql to create your queries.');
        }
    }
}
exports.assertSql = assertSql;
async function executeAndReturnAll(driver, queries) {
    return driver.executeAndReturnAll(queries);
}
exports.executeAndReturnAll = executeAndReturnAll;
async function executeAndReturnLast(driver, queries) {
    return driver.executeAndReturnLast(queries);
}
exports.executeAndReturnLast = executeAndReturnLast;
async function queryInternal(driver, queries, fn) {
    const hasTransaction = queries.length > 1;
    try {
        if (hasTransaction) {
            await driver.beginTransaction(undefined);
        }
        const results = await fn(driver, queries);
        if (hasTransaction) {
            await driver.commitTransaction();
        }
        return results;
    }
    catch (ex) {
        if (hasTransaction) {
            await driver.rollbackTransaction();
        }
        throw ex;
    }
}
exports.queryInternal = queryInternal;
async function taskInternal(driver, factories, fn) {
    const connection = factories.createConnection(driver);
    try {
        return await fn(connection);
    }
    finally {
        await connection.dispose();
    }
}
exports.taskInternal = taskInternal;
async function txInternal(driver, factories, fn, options, addPostCommitStep) {
    let failureCount = 0;
    while (true) {
        await driver.beginTransaction(options);
        const tx = factories.createTransaction(driver, { addPostCommitStep });
        let result;
        try {
            result = await fn(tx);
            await tx.dispose();
            await driver.commitTransaction();
        }
        catch (ex) {
            await tx.dispose();
            await driver.rollbackTransaction();
            if (await driver.shouldRetryTransactionFailure(options, ex, ++failureCount)) {
                continue;
            }
            throw ex;
        }
        return result;
    }
}
exports.txInternal = txInternal;
//# sourceMappingURL=utils.js.map