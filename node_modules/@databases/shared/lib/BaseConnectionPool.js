"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const connection_pool_1 = require("@databases/connection-pool");
const split_sql_query_1 = require("@databases/split-sql-query");
const QueryableType_1 = require("./QueryableType");
const utils_1 = require("./utils");
const returnFalse = () => false;
class BaseConnectionPool {
    constructor(options, factories) {
        this.type = QueryableType_1.default.ConnectionPool;
        this._disposed = false;
        this._pool = (0, connection_pool_1.default)(options);
        this._factories = factories;
    }
    async _withDriverFromPool(fn, ...args) {
        let releasing = false;
        const driver = await this._pool.getConnection();
        try {
            const result = await fn(driver.connection, ...args);
            releasing = true;
            driver.release();
            return result;
        }
        catch (ex) {
            if (releasing) {
                throw ex;
            }
            if (await driver.connection
                .canRecycleConnectionAfterError(ex)
                .catch(returnFalse)) {
                releasing = true;
                driver.release();
            }
            else {
                releasing = true;
                driver.dispose();
            }
            throw ex;
        }
    }
    _throwIfDisposed() {
        if (this._disposed) {
            throw new Error('You cannot run any operations on a ConnectionPool after it has been disposed.');
        }
    }
    async task(fn) {
        this._throwIfDisposed();
        return this._withDriverFromPool(utils_1.taskInternal, this._factories, fn);
    }
    async tx(fn, options) {
        this._throwIfDisposed();
        const postCommitSteps = [];
        const result = await this._withDriverFromPool(utils_1.txInternal, this._factories, fn, options, (fn) => {
            postCommitSteps.push(fn);
        });
        for (const step of postCommitSteps) {
            await step();
        }
        return result;
    }
    async query(query) {
        (0, utils_1.assertSql)(query);
        this._throwIfDisposed();
        if (Array.isArray(query)) {
            if (query.length === 0)
                return [];
            return this._withDriverFromPool(utils_1.queryInternal, query, utils_1.executeAndReturnAll);
        }
        else {
            return this._withDriverFromPool(utils_1.queryInternal, (0, split_sql_query_1.default)(query), utils_1.executeAndReturnLast);
        }
    }
    async addPostCommitStep(fn) {
        await fn();
    }
    async *queryStream(query, options) {
        (0, utils_1.assertSql)(query);
        this._throwIfDisposed();
        const poolRecord = await this._pool.getConnection();
        try {
            for await (const record of poolRecord.connection.queryStream(query, options)) {
                yield record;
            }
        }
        finally {
            poolRecord.dispose();
        }
    }
    async dispose() {
        this._disposed = true;
        await this._pool.drain();
    }
}
exports.default = BaseConnectionPool;
//# sourceMappingURL=BaseConnectionPool.js.map