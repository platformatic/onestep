"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const split_sql_query_1 = require("@databases/split-sql-query");
const QueryableType_1 = require("./QueryableType");
const utils_1 = require("./utils");
const lock_1 = require("@databases/lock");
class BaseConnection {
    constructor(driver, factories) {
        this.type = QueryableType_1.default.Connection;
        this._driver = driver;
        this._factories = factories;
        this._lock = (0, lock_1.createLock)(driver.acquireLockTimeoutMilliseconds);
    }
    _throwIfDisposed() {
        if (this._disposed) {
            throw new Error('You cannot run any operations on a Connection after it has been returned to the pool.');
        }
    }
    async task(fn) {
        this._throwIfDisposed();
        return await fn(this);
    }
    async tx(fn, options) {
        this._throwIfDisposed();
        const postCommitSteps = [];
        await this._lock.acquireLock();
        let result;
        try {
            result = await (0, utils_1.txInternal)(this._driver, this._factories, fn, options, (fn) => {
                postCommitSteps.push(fn);
            });
        }
        finally {
            this._lock.releaseLock();
        }
        for (const step of postCommitSteps) {
            await step();
        }
        return result;
    }
    async query(query) {
        (0, utils_1.assertSql)(query);
        this._throwIfDisposed();
        if (Array.isArray(query)) {
            if (query.length === 0)
                return [];
            await this._lock.acquireLock();
            try {
                return await (0, utils_1.queryInternal)(this._driver, query, utils_1.executeAndReturnAll);
            }
            finally {
                this._lock.releaseLock();
            }
        }
        else {
            await this._lock.acquireLock();
            try {
                return await (0, utils_1.queryInternal)(this._driver, (0, split_sql_query_1.default)(query), utils_1.executeAndReturnLast);
            }
            finally {
                this._lock.releaseLock();
            }
        }
    }
    async addPostCommitStep(fn) {
        await fn();
    }
    async *queryStream(query, options) {
        (0, utils_1.assertSql)(query);
        this._throwIfDisposed();
        await this._lock.acquireLock();
        try {
            for await (const record of this._driver.queryStream(query, options)) {
                yield record;
            }
        }
        finally {
            this._lock.releaseLock();
        }
    }
    async dispose() {
        return this._disposed || (this._disposed = this._lock.pool());
    }
}
exports.default = BaseConnection;
//# sourceMappingURL=BaseConnection.js.map