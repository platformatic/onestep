"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const split_sql_query_1 = require("@databases/split-sql-query");
const cuid = require("cuid");
const QueryableType_1 = require("./QueryableType");
const lock_1 = require("@databases/lock");
const utils_1 = require("./utils");
class BaseTransaction {
    constructor(driver, factories, parentContext) {
        this.type = QueryableType_1.default.Transaction;
        this._driver = driver;
        this._factories = factories;
        this._lock = (0, lock_1.createLock)(driver.acquireLockTimeoutMilliseconds);
        this._parentContext = parentContext;
    }
    _throwIfDisposed() {
        if (this._disposed) {
            throw new Error('You cannot run any operations on a Transaction after it has been committed or rolled back.');
        }
    }
    async task(fn) {
        this._throwIfDisposed();
        return await fn(this);
    }
    async tx(fn) {
        this._throwIfDisposed();
        await this._lock.acquireLock();
        try {
            const savepointName = cuid();
            await this._driver.createSavepoint(savepointName);
            const subTransaction = this._factories.createTransaction(this._driver, this._parentContext);
            try {
                const result = await fn(subTransaction);
                await subTransaction.dispose();
                await this._driver.releaseSavepoint(savepointName);
                return result;
            }
            catch (ex) {
                await subTransaction.dispose();
                await this._driver.rollbackToSavepoint(savepointName);
                throw ex;
            }
        }
        finally {
            this._lock.releaseLock();
        }
    }
    async query(query) {
        (0, utils_1.assertSql)(query);
        this._throwIfDisposed();
        await this._lock.acquireLock();
        try {
            if (Array.isArray(query)) {
                if (query.length === 0)
                    return [];
                return await this._driver.executeAndReturnAll(query);
            }
            else {
                return await this._driver.executeAndReturnLast((0, split_sql_query_1.default)(query));
            }
        }
        finally {
            this._lock.releaseLock();
        }
    }
    async addPostCommitStep(fn) {
        this._parentContext.addPostCommitStep(fn);
    }
    async *queryStream(query, options) {
        (0, utils_1.assertSql)(query);
        this._throwIfDisposed();
        await this._lock.acquireLock();
        try {
            for await (const record of this._driver.queryStream(query, options)) {
                yield record;
            }
        }
        finally {
            this._lock.releaseLock();
        }
    }
    async dispose() {
        return this._disposed || (this._disposed = this._lock.pool());
    }
}
exports.default = BaseTransaction;
//# sourceMappingURL=BaseTransaction.js.map