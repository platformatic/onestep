"use strict";
/**
 * This file handles 33.1.2 from https://www.postgresql.org/docs/13/libpq-connect.html
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EnvironmentVariables_1 = require("./EnvironmentVariables");

class ConfigurationBuilder {
  constructor(options) {
    this._config = {
      host: [],
      hostaddr: [],
      port: []
    };
    this._options = { ...options,
      envVarName: null
    };
  }

  getConfig() {
    for (const [envVarName, configParamName] of EnvironmentVariables_1.default) {
      const currentValue = this._config[configParamName];

      if (!currentValue || Array.isArray(currentValue) && currentValue.length === 0) {
        const envVarValue = this._options.env[envVarName];

        if (envVarValue) {
          try {
            this._options.envVarName = envVarName;
            this.set(configParamName, envVarValue);
          } finally {
            this._options.envVarName = null;
          }
        }
      }
    }

    if (!this._config.sslmode) {
      const envVarValue = this._options.env.PGREQUIRESSL;

      if (envVarValue) {
        try {
          this._options.envVarName = 'PGREQUIRESSL';
          this.set('requiressl', envVarValue);
        } finally {
          this._options.envVarName = null;
        }
      }
    }

    return { ...this._config
    };
  }

  set(paramName, paramValue) {
    switch (paramName) {
      // Non standard parameters
      case 'ssl':
        // Non standard param for compatability with 'pg' npm package
        if (!this._config.sslmode) {
          parseEnum(this._options, [[['true', '1'], 'require'], ['0', 'disable']])(sslmode => this._config.sslmode = sslmode, 'ssl', paramValue);
        }

        break;
      // standard parameters

      case 'host':
        for (const val of paramValue.split(',')) {
          this._config.host.push(val);
        }

        break;

      case 'hostaddr':
        for (const val of paramValue.split(',')) {
          this._config.hostaddr.push(val);
        }

        break;

      case 'port':
        for (const val of paramValue.split(',')) {
          parseInteger(this._options, port => this._config.port.push(port), 'port', val);
        }

        break;

      case 'dbname':
        this._config.dbname = paramValue;
        break;

      case 'user':
        this._config.user = paramValue;
        break;

      case 'password':
        this._config.password = paramValue;
        break;

      case 'passfile':
        this._config.passfile = paramValue;
        break;

      case 'connect_timeout':
        parseInteger(this._options, this._config, 'connect_timeout', paramValue, 'seconds');

        if (this._config.connect_timeout && this._config.connect_timeout < 2) {
          this._config.connect_timeout = 2;
        }

        break;

      case 'client_encoding':
        // TODO: handle auto?
        this._config.client_encoding = paramValue;
        break;

      case 'options':
        this._config.options = paramValue;
        break;

      case 'application_name':
        this._config.application_name = paramValue;
        break;

      case 'fallback_application_name':
        this._config.fallback_application_name = paramValue;
        break;

      case 'keepalives':
        parseEnum(this._options, [['1', true], ['0', false]])(this._config, 'keepalives', paramValue);
        break;

      case 'keepalives_idle':
        parseInteger(this._options, this._config, 'keepalives_idle', paramValue, 'seconds');
        break;

      case 'keepalives_interval':
        parseInteger(this._options, this._config, 'keepalives_interval', paramValue, 'seconds');
        break;

      case 'keepalives_count':
        parseInteger(this._options, this._config, 'keepalives_count', paramValue);
        break;

      case 'tcp_user_timeout':
        parseInteger(this._options, this._config, 'tcp_user_timeout', paramValue, 'milliseconds');
        break;

      case 'tty':
        // Ignored (formerly, this specified where to send server debug output).
        break;

      case 'replication':
        parseEnum(this._options, [[['true', 'on', 'yes', '1'], true], [['false', 'off', 'no', '0'], false], ['database', 'database']])(this._config, 'replication', paramValue);
        break;

      case 'gssencmode':
        parseEnum(this._options, [['disable', 'disable'], ['prefer', 'prefer'], ['require', 'require']])(this._config, 'gssencmode', paramValue);
        break;

      case 'sslmode':
        parseEnum(this._options, [['disable', 'disable'], ['allow', 'allow'], ['prefer', 'prefer'], ['require', 'require'], ['verify-ca', 'verify-ca'], ['verify-full', 'verify-full'], ['no-verify', 'no-verify']])(this._config, 'sslmode', paramValue);
        break;

      case 'requiressl':
        // This option is deprecated in favor of the sslmode setting.
        if (!this._config.sslmode) {
          parseEnum(this._options, [['1', 'require'], ['0', 'prefer']])(sslmode => this._config.sslmode = sslmode, 'requiressl', paramValue);
        }

        break;

      case 'sslcompression':
        parseEnum(this._options, [['1', true], ['0', false]])(this._config, 'sslcompression', paramValue);
        break;

      case 'sslcert':
        this._config.sslcert = paramValue;
        break;

      case 'sslkey':
        this._config.sslkey = paramValue;
        break;

      case 'sslpassword':
        this._config.sslpassword = paramValue;
        break;

      case 'sslrootcert':
        this._config.sslrootcert = paramValue;
        break;

      case 'sslcrl':
        this._config.sslcrl = paramValue;
        break;

      case 'requirepeer':
        this._config.requirepeer = paramValue;
        break;

      case 'ssl_min_protocol_version':
        parseEnum(this._options, [['TLSv1', 'TLSv1'], ['TLSv1.1', 'TLSv1.1'], ['TLSv1.2', 'TLSv1.2'], ['TLSv1.3', 'TLSv1.3']])(this._config, 'ssl_min_protocol_version', paramValue);
        break;

      case 'ssl_max_protocol_version':
        parseEnum(this._options, [['TLSv1', 'TLSv1'], ['TLSv1.1', 'TLSv1.1'], ['TLSv1.2', 'TLSv1.2'], ['TLSv1.3', 'TLSv1.3']])(this._config, 'ssl_max_protocol_version', paramValue);
        break;

      case 'krbsrvname':
        this._config.krbsrvname = paramValue;
        break;

      case 'gsslib':
        this._config.gsslib = paramValue;
        break;

      case 'service':
        this._config.service = paramValue;
        break;

      case 'target_session_attrs':
        parseEnum(this._options, [['read-write', 'read-write'], ['any', 'any']])(this._config, 'target_session_attrs', paramValue);
        break;

      default:
        if (this._options.envVarName) {
          throw new Error(`The environment variable "${this._options.envVarName}" was mapped to an unrecognized parameter name, "${paramName}".  This is probably a bug in @databases/pg-connection-string, not a mistake in your config. Please open an issue at https://github.com/ForbesLindesay/atdatabases/issues to report this.`);
        } else if (this._options.unrecognisedOptionMode === 'error') {
          throw new Error(`Unrecognised option in connection string: ${paramName}`);
        } else if (this._options.unrecognisedOptionMode === 'warn') {
          console.warn(`Warning: Ignoring unrecognised option in connection string: ${paramName}`);
        } else if (typeof this._options.unrecognisedOptionMode === 'function') {
          this._options.unrecognisedOptionMode(paramName, paramValue);
        }

        break;
    }
  }

}

exports.ConfigurationBuilder = ConfigurationBuilder;

function parseInteger(options, obj, paramName, value, unit) {
  var _a, _b;

  if (!/^\d+$/.test(value)) {
    if (options.invalidOptionMode === 'error') {
      throw new Error(`Expected "${(_a = options.envVarName) !== null && _a !== void 0 ? _a : paramName}" to be an integer${unit ? ` in ${unit}` : ``}`);
    } else if (options.invalidOptionMode === 'warn') {
      console.warn(`Warning: Expected "${(_b = options.envVarName) !== null && _b !== void 0 ? _b : paramName}" to be an integer${unit ? ` in ${unit}` : ``} - ignoring invalid value!!`);
    }

    return;
  }

  const val = parseInt(value, 10);

  if (typeof obj === 'function') {
    obj(val);
  } else {
    if (val > 0) {
      obj[paramName] = val;
    } else if (paramName in obj) {
      delete obj[paramName];
    }
  }
}

function parseEnum(options, mapping) {
  return (obj, paramName, value) => {
    var _a, _b;

    for (const [keys, outputValue] of mapping) {
      if (typeof keys === 'string' ? value === keys : keys.includes(value)) {
        if (typeof obj === 'function') {
          obj(outputValue);
        } else {
          obj[paramName] = outputValue;
        }

        return;
      }
    }

    if (options.invalidOptionMode === 'error') {
      throw new Error(`Expected "${(_a = options.envVarName) !== null && _a !== void 0 ? _a : paramName}" to be one of ${mapping.map(value => typeof value === 'string' ? `"${value}"` : value.map(v => `"${v}"`).join(', ')).join(', ')}`);
    } else if (options.invalidOptionMode === 'warn') {
      console.warn(`Warning: Expected "${(_b = options.envVarName) !== null && _b !== void 0 ? _b : paramName}" to be one of ${mapping.map(value => typeof value === 'string' ? `"${value}"` : value.map(v => `"${v}"`).join(', ')).join(', ')} - ignoring invalid value!!`);
    }
  };
}