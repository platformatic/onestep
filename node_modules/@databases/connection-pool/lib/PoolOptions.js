"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolOptionsObject = void 0;
const errors_1 = require("./utils/errors");
const timeout_1 = require("./utils/timeout");
function zeroToInfinity(value, defaultValue = Infinity) {
    if (value === undefined) {
        return defaultValue;
    }
    else if (value === 0) {
        return Infinity;
    }
    else {
        return value;
    }
}
class PoolOptionsObject {
    constructor(options) {
        this._onConnectionAfterTimeout = (connection) => {
            void this.closeConnection(connection);
        };
        this._onConnectionClosed = (timeout) => {
            if ((0, timeout_1.isTimeout)(timeout)) {
                if (this._options.onTimeoutClosingConnection) {
                    this._options.onTimeoutClosingConnection();
                }
                else {
                    console.warn(`pool.closeConnetion timed out after ${this._closeConnectionTimeoutMilliseconds}ms`);
                }
            }
        };
        this._onConnectionError = (err) => {
            if (this._options.onErrorClosingConnection) {
                this._options.onErrorClosingConnection(err);
            }
            else {
                console.error(`Error closing connection: ${err.stack}`);
            }
        };
        this._options = options;
        this.maxSize = zeroToInfinity(options.maxSize);
        this.maxUses = zeroToInfinity(options.maxUses);
        this.idleTimeoutMilliseconds = zeroToInfinity(options.idleTimeoutMilliseconds);
        this.releaseTimeoutMilliseconds = zeroToInfinity(options.releaseTimeoutMilliseconds);
        this.queueTimeoutMilliseconds = zeroToInfinity(options.queueTimeoutMilliseconds);
        this._openConnectionTimeoutMilliseconds = zeroToInfinity(options.openConnectionTimeoutMilliseconds, 60000);
        this._closeConnectionTimeoutMilliseconds = zeroToInfinity(options.closeConnectionTimeoutMilliseconds, 60000);
        this.connectionLimitBackoffMilliseconds =
            options.connectionLimitBackoffMilliseconds || 5000;
        if (this._options.releaseTimeoutMilliseconds !== undefined &&
            !this._options.onReleaseTimeout) {
            throw new Error(`If you specify releaseTimeoutMilliseconds you must provide a handler for onReleaseTimeout`);
        }
    }
    async openConnection(removeFromPool) {
        return (0, timeout_1.withTimeout)(this._options.openConnection, {
            timeoutMilliseconds: this._openConnectionTimeoutMilliseconds,
            onResultAfterTimeout: this._onConnectionAfterTimeout,
        }, removeFromPool);
    }
    async closeConnection(connection) {
        return (0, timeout_1.withTimeout)(this._options.closeConnection, { timeoutMilliseconds: this._closeConnectionTimeoutMilliseconds }, connection)
            .then(this._onConnectionClosed, this._onConnectionError)
            .catch(errors_1.globalError);
    }
    onActive(connection) {
        return (0, errors_1.attemptHook)(this._options.onActive, connection);
    }
    onIdle(connection) {
        return (0, errors_1.attemptHook)(this._options.onIdle, connection);
    }
    onReleaseTimeout(connection) {
        void (0, timeout_1.withTimeout)(this._options.onReleaseTimeout, { timeoutMilliseconds: this._closeConnectionTimeoutMilliseconds }, connection)
            .then(this._onConnectionClosed, this._onConnectionError)
            .catch(errors_1.globalError);
    }
    isConnectionLimitError(err) {
        try {
            return this._options.isConnectionLimitError
                ? this._options.isConnectionLimitError(err)
                : false;
        }
        catch (ex) {
            (0, errors_1.globalError)(ex);
            return false;
        }
    }
}
exports.PoolOptionsObject = PoolOptionsObject;
//# sourceMappingURL=PoolOptions.js.map