"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const queue_1 = require("@databases/queue");
const defer_1 = require("./utils/defer");
const errors_1 = require("./utils/errors");
const timeout_1 = require("./utils/timeout");
const Waiter_1 = require("./utils/Waiter");
const IPoolRecord_1 = require("./IPoolRecord");
const PoolOptions_1 = require("./PoolOptions");
const RESOLVED_PROMISE = Promise.resolve();
class PoolConnectionImpl {
    constructor(record, pool, onReleaseTimeout, releaseTimeoutMilliseconds) {
        this._released = false;
        this._timedOut = false;
        this.connection = record.connection;
        this._record = record;
        this._pool = pool;
        if (releaseTimeoutMilliseconds !== Infinity) {
            this._timeout = setTimeout(() => {
                this._timedOut = true;
                onReleaseTimeout(record);
            }, releaseTimeoutMilliseconds);
        }
    }
    release() {
        if (this._timedOut) {
            return;
        }
        if (this._timeout !== undefined) {
            clearTimeout(this._timeout);
        }
        if (this._released) {
            throw (0, errors_1.doubleReleaseError)();
        }
        this._released = true;
        this._pool._releaseConnection(this._record);
    }
    dispose() {
        if (this._timedOut) {
            return;
        }
        if (this._timeout !== undefined) {
            clearTimeout(this._timeout);
        }
        if (this._released) {
            throw (0, errors_1.doubleReleaseError)();
        }
        this._released = true;
        this._pool._closeConnection(this._record);
    }
}
class ConnectionPoolState {
    constructor(options) {
        this._isDraining = false;
        this._totalConnectionsCount = 0;
        this._idleConnections = new queue_1.default();
        this._waiters = new queue_1.default();
        this._onIdleTimeout = (record) => {
            this._closeConnection(record);
        };
        this._onReleaseTimeout = (record) => {
            const connection = record.connection;
            (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Disposed);
            this._decreaseTotalConnectionsCount();
            this._options.onReleaseTimeout(connection);
        };
        this._options = options;
        const [drained, onDrained] = (0, defer_1.default)();
        this._drained = drained;
        this._onDrained = onDrained;
    }
    _increaseTotalConnectionsCount() {
        this._totalConnectionsCount++;
    }
    _decreaseTotalConnectionsCount() {
        this._totalConnectionsCount--;
        const nextWaiter = this._getNextWaiter();
        if (nextWaiter) {
            nextWaiter.resolve(this._openConnection());
        }
        if (this._isDraining && this._totalConnectionsCount === 0) {
            this._onDrained();
        }
    }
    _canOpenConnection() {
        if (!this._options.maxSize)
            return true;
        return this._totalConnectionsCount < this._options.maxSize;
    }
    async _openConnection() {
        const [destroyed, destroy] = (0, defer_1.default)();
        this._increaseTotalConnectionsCount();
        return RESOLVED_PROMISE.then(() => this._options.openConnection(destroy))
            .then((connection) => {
            if ((0, timeout_1.isTimeout)(connection)) {
                throw (0, errors_1.openTimeout)();
            }
            const record = (0, IPoolRecord_1.getPoolRecord)(connection);
            const r = record;
            void destroyed.then(() => {
                if ((0, IPoolRecord_1.isActivePoolRecord)(r)) {
                    r.shouldDestroy = true;
                }
                else if ((0, IPoolRecord_1.isIdlePoolRecord)(r)) {
                    this._closeConnection(r);
                }
            });
            return record;
        })
            .catch((err) => {
            if (this._totalConnectionsCount > 1 &&
                this._options.isConnectionLimitError(err)) {
                this._totalConnectionsCount--;
                const maxSizeReduction = this._options.maxSize - this._totalConnectionsCount;
                this._options.maxSize -= maxSizeReduction;
                setTimeout(() => {
                    this._totalConnectionsCount++;
                    this._options.maxSize += maxSizeReduction;
                    this._decreaseTotalConnectionsCount();
                    return errors_1.connectionLimitExceeded;
                }, this._options.connectionLimitBackoffMilliseconds);
                return errors_1.connectionLimitExceeded;
            }
            this._decreaseTotalConnectionsCount();
            throw err;
        });
    }
    _releaseConnection(record) {
        if (!(0, IPoolRecord_1.isActivePoolRecord)(record)) {
            throw new Error('Cannot call releaseConnection when record that is not active');
        }
        if (record.shouldDestroy || record.activateCount >= this._options.maxUses) {
            this._closeConnection(record);
            return;
        }
        const waiter = this._getNextWaiter();
        if (waiter) {
            waiter.resolve(record);
        }
        else if (this._isDraining) {
            this._closeConnection(record);
        }
        else {
            const err = this._options.onIdle(record.connection);
            if (err) {
                this._decreaseTotalConnectionsCount();
                throw err;
            }
            this._idleConnections.push((0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Idle, this._onIdleTimeout, this._options.idleTimeoutMilliseconds));
        }
    }
    _closeConnection(record) {
        const connection = record.connection;
        if ((0, IPoolRecord_1.isDisposedPoolRecord)(record)) {
            throw new Error('Cannot call closeConnection when record is already disposed');
        }
        (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Disposed);
        this._options.closeConnection(connection).then(() => {
            this._decreaseTotalConnectionsCount();
        }, () => {
            this._decreaseTotalConnectionsCount();
        });
    }
    _getNextIdleRecord() {
        while (true) {
            const record = this._idleConnections.shift();
            if (record === undefined || (0, IPoolRecord_1.isIdlePoolRecord)(record)) {
                return record;
            }
        }
    }
    _getNextWaiter() {
        while (true) {
            const record = this._waiters.shift();
            if (record === undefined || !record.isTimedOut()) {
                return record;
            }
        }
    }
    /**
     * Retrieve a connection from the connection pool.
     *
     * N.B. you must call either `release` or `dispose`
     * otherwise your connection pool will eventually
     * be stuck and your app will stall.
     */
    async getConnection() {
        var _a;
        const record = (_a = this._getNextIdleRecord()) !== null && _a !== void 0 ? _a : (this._canOpenConnection()
            ? await this._openConnection()
            : await new Promise((resolve) => {
                this._waiters.push(new Waiter_1.default(resolve, this._options.queueTimeoutMilliseconds));
            }));
        if (record === errors_1.connectionLimitExceeded) {
            return await this.getConnection();
        }
        if ((0, timeout_1.isTimeout)(record)) {
            throw (0, errors_1.queueTimeoutError)();
        }
        if ((0, IPoolRecord_1.isIdlePoolRecord)(record)) {
            const err = this._options.onActive(record.connection);
            if (err) {
                this._decreaseTotalConnectionsCount();
                throw err;
            }
        }
        const activeRecord = (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Active);
        return new PoolConnectionImpl(activeRecord, this, this._onReleaseTimeout, this._options.releaseTimeoutMilliseconds);
    }
    /**
     * How many connections are currently active, both
     * idle connections in the pool, and connections that
     * are in use.
     */
    getConnectionsCount() {
        return this._totalConnectionsCount;
    }
    /**
     * How many connections are active, but not currently
     * in use.
     *
     * TODO: this may not be accurate
     */
    getIdleConnectionsCount() {
        return this._idleConnections.getLength();
    }
    /**
     * How many processes are in the queue waiting for
     * a connection.
     */
    getQueueLength() {
        return this._waiters.getLength();
    }
    async drain() {
        this._isDraining = true;
        for (const connection of this._idleConnections.clear()) {
            if ((0, IPoolRecord_1.isIdlePoolRecord)(connection)) {
                this._closeConnection(connection);
            }
        }
        if (this._totalConnectionsCount === 0) {
            this._onDrained();
        }
        await this._drained;
    }
}
/**
 * Create a new ConnectionPool to manage connections
 */
function createConnectionPool(options) {
    return new ConnectionPoolState(new PoolOptions_1.PoolOptionsObject(options));
}
exports.default = createConnectionPool;
module.exports = Object.assign(createConnectionPool, {
    default: createConnectionPool,
});
//# sourceMappingURL=index.js.map