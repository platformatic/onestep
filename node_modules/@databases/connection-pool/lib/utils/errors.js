"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConnectionLimitExceeded = exports.connectionLimitExceeded = exports.attemptHook = exports.globalError = exports.doubleReleaseError = exports.queueTimeoutError = exports.openTimeout = void 0;
function openTimeout() {
    return Object.assign(new Error(`Timed out waiting for open connection.`), {
        code: `CONNECTION_POOL:OPEN_TIMEOUT`,
    });
}
exports.openTimeout = openTimeout;
function queueTimeoutError() {
    return Object.assign(new Error('Timed out waiting for connection from pool.'), {
        code: 'CONNECTION_POOL:QUEUE_TIMEOUT',
    });
}
exports.queueTimeoutError = queueTimeoutError;
function doubleReleaseError() {
    return Object.assign(new Error('Release called on client which has already been released to the pool.'), { code: 'CONNECTION_POOL:DOUBLE_RELEASE' });
}
exports.doubleReleaseError = doubleReleaseError;
function globalError(err) {
    setTimeout(() => {
        throw err;
    }, 0);
}
exports.globalError = globalError;
function attemptHook(fn, ...args) {
    try {
        if (fn) {
            fn(...args);
        }
        return undefined;
    }
    catch (ex) {
        return ex;
    }
}
exports.attemptHook = attemptHook;
exports.connectionLimitExceeded = Symbol('CONNECTION_LIMIT_EXCEEDED');
function isConnectionLimitExceeded(value) {
    return value === exports.connectionLimitExceeded;
}
exports.isConnectionLimitExceeded = isConnectionLimitExceeded;
//# sourceMappingURL=errors.js.map