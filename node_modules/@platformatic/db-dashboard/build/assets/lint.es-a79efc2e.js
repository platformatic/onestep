import{C as G}from"./codemirror.es-1780c92c.js";import{K as u,G as p,d as _,i as fe,a as w,n as de,b as F,s as R,t as h,c as $,p as v,e as X,f as y,h as E,D as T,O as J,j as Le,k as Me,l as O,m as k,o as I,q as U,r as re,u as Ye,v as Be,w as pe,x as C,y as me,z as V,A as Xe,B as qe,C as Ge,E as Je,F as Qe,H as He,I as Ke,J as se,T as ge,L as Ee,M as Te,N as We,P as ze,Q as Ze,R as xe,S as en,U as nn}from"./index-537712ce.js";import{R as Ne,P as j}from"./Range.es-3e45690c.js";function tn(e){return e.kind===u.OPERATION_DEFINITION||e.kind===u.FRAGMENT_DEFINITION}function rn(e){return e.kind===u.SCHEMA_DEFINITION||q(e)||e.kind===u.DIRECTIVE_DEFINITION}function q(e){return e.kind===u.SCALAR_TYPE_DEFINITION||e.kind===u.OBJECT_TYPE_DEFINITION||e.kind===u.INTERFACE_TYPE_DEFINITION||e.kind===u.UNION_TYPE_DEFINITION||e.kind===u.ENUM_TYPE_DEFINITION||e.kind===u.INPUT_OBJECT_TYPE_DEFINITION}function sn(e){return e.kind===u.SCHEMA_EXTENSION||ve(e)}function ve(e){return e.kind===u.SCALAR_TYPE_EXTENSION||e.kind===u.OBJECT_TYPE_EXTENSION||e.kind===u.INTERFACE_TYPE_EXTENSION||e.kind===u.UNION_TYPE_EXTENSION||e.kind===u.ENUM_TYPE_EXTENSION||e.kind===u.INPUT_OBJECT_TYPE_EXTENSION}function ye(e){return{Document(n){for(const t of n.definitions)if(!tn(t)){const i=t.kind===u.SCHEMA_DEFINITION||t.kind===u.SCHEMA_EXTENSION?"schema":'"'+t.name.value+'"';e.reportError(new p(`The ${i} definition is not executable.`,{nodes:t}))}return!1}}}function on(e){return{Field(n){const t=e.getParentType();if(t&&!e.getFieldDef()){const r=e.getSchema(),s=n.name.value;let a=_("to use an inline fragment on",an(r,t,s));a===""&&(a=_(ln(t,s))),e.reportError(new p(`Cannot query field "${s}" on type "${t.name}".`+a,{nodes:n}))}}}}function an(e,n,t){if(!fe(n))return[];const i=new Set,r=Object.create(null);for(const a of e.getPossibleTypes(n))if(a.getFields()[t]){i.add(a),r[a.name]=1;for(const o of a.getInterfaces()){var s;o.getFields()[t]&&(i.add(o),r[o.name]=((s=r[o.name])!==null&&s!==void 0?s:0)+1)}}return[...i].sort((a,o)=>{const l=r[o.name]-r[a.name];return l!==0?l:w(a)&&e.isSubType(a,o)?-1:w(o)&&e.isSubType(o,a)?1:de(a.name,o.name)}).map(a=>a.name)}function ln(e,n){if(F(e)||w(e)){const t=Object.keys(e.getFields());return R(n,t)}return[]}function cn(e){return{InlineFragment(n){const t=n.typeCondition;if(t){const i=h(e.getSchema(),t);if(i&&!$(i)){const r=v(t);e.reportError(new p(`Fragment cannot condition on non composite type "${r}".`,{nodes:t}))}}},FragmentDefinition(n){const t=h(e.getSchema(),n.typeCondition);if(t&&!$(t)){const i=v(n.typeCondition);e.reportError(new p(`Fragment "${n.name.value}" cannot condition on non composite type "${i}".`,{nodes:n.typeCondition}))}}}}function un(e){return{...fn(e),Argument(n){const t=e.getArgument(),i=e.getFieldDef(),r=e.getParentType();if(!t&&i&&r){const s=n.name.value,a=i.args.map(l=>l.name),o=R(s,a);e.reportError(new p(`Unknown argument "${s}" on field "${r.name}.${i.name}".`+_(o),{nodes:n}))}}}}function fn(e){const n=Object.create(null),t=e.getSchema(),i=t?t.getDirectives():X;for(const a of i)n[a.name]=a.args.map(o=>o.name);const r=e.getDocument().definitions;for(const a of r)if(a.kind===u.DIRECTIVE_DEFINITION){var s;const o=(s=a.arguments)!==null&&s!==void 0?s:[];n[a.name.value]=o.map(l=>l.name.value)}return{Directive(a){const o=a.name.value,l=n[o];if(a.arguments&&l)for(const c of a.arguments){const f=c.name.value;if(!l.includes(f)){const d=R(f,l);e.reportError(new p(`Unknown argument "${f}" on directive "@${o}".`+_(d),{nodes:c}))}}return!1}}}function Ie(e){const n=Object.create(null),t=e.getSchema(),i=t?t.getDirectives():X;for(const s of i)n[s.name]=s.locations;const r=e.getDocument().definitions;for(const s of r)s.kind===u.DIRECTIVE_DEFINITION&&(n[s.name.value]=s.locations.map(a=>a.value));return{Directive(s,a,o,l,c){const f=s.name.value,d=n[f];if(!d){e.reportError(new p(`Unknown directive "@${f}".`,{nodes:s}));return}const m=dn(c);m&&!d.includes(m)&&e.reportError(new p(`Directive "@${f}" may not be used on ${m}.`,{nodes:s}))}}}function dn(e){const n=e[e.length-1];switch("kind"in n||y(!1),n.kind){case u.OPERATION_DEFINITION:return pn(n.operation);case u.FIELD:return T.FIELD;case u.FRAGMENT_SPREAD:return T.FRAGMENT_SPREAD;case u.INLINE_FRAGMENT:return T.INLINE_FRAGMENT;case u.FRAGMENT_DEFINITION:return T.FRAGMENT_DEFINITION;case u.VARIABLE_DEFINITION:return T.VARIABLE_DEFINITION;case u.SCHEMA_DEFINITION:case u.SCHEMA_EXTENSION:return T.SCHEMA;case u.SCALAR_TYPE_DEFINITION:case u.SCALAR_TYPE_EXTENSION:return T.SCALAR;case u.OBJECT_TYPE_DEFINITION:case u.OBJECT_TYPE_EXTENSION:return T.OBJECT;case u.FIELD_DEFINITION:return T.FIELD_DEFINITION;case u.INTERFACE_TYPE_DEFINITION:case u.INTERFACE_TYPE_EXTENSION:return T.INTERFACE;case u.UNION_TYPE_DEFINITION:case u.UNION_TYPE_EXTENSION:return T.UNION;case u.ENUM_TYPE_DEFINITION:case u.ENUM_TYPE_EXTENSION:return T.ENUM;case u.ENUM_VALUE_DEFINITION:return T.ENUM_VALUE;case u.INPUT_OBJECT_TYPE_DEFINITION:case u.INPUT_OBJECT_TYPE_EXTENSION:return T.INPUT_OBJECT;case u.INPUT_VALUE_DEFINITION:{const t=e[e.length-3];return"kind"in t||y(!1),t.kind===u.INPUT_OBJECT_TYPE_DEFINITION?T.INPUT_FIELD_DEFINITION:T.ARGUMENT_DEFINITION}default:y(!1,"Unexpected kind: "+E(n.kind))}}function pn(e){switch(e){case J.QUERY:return T.QUERY;case J.MUTATION:return T.MUTATION;case J.SUBSCRIPTION:return T.SUBSCRIPTION}}function he(e){return{FragmentSpread(n){const t=n.name.value;e.getFragment(t)||e.reportError(new p(`Unknown fragment "${t}".`,{nodes:n.name}))}}}function Oe(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),i=Object.create(null);for(const s of e.getDocument().definitions)q(s)&&(i[s.name.value]=!0);const r=[...Object.keys(t),...Object.keys(i)];return{NamedType(s,a,o,l,c){const f=s.name.value;if(!t[f]&&!i[f]){var d;const m=(d=c[2])!==null&&d!==void 0?d:o,g=m!=null&&mn(m);if(g&&oe.includes(f))return;const N=R(f,g?oe.concat(r):r);e.reportError(new p(`Unknown type "${f}".`+_(N),{nodes:s}))}}}}const oe=[...Le,...Me].map(e=>e.name);function mn(e){return"kind"in e&&(rn(e)||sn(e))}function gn(e){let n=0;return{Document(t){n=t.definitions.filter(i=>i.kind===u.OPERATION_DEFINITION).length},OperationDefinition(t){!t.name&&n>1&&e.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:t}))}}}function En(e){var n,t,i;const r=e.getSchema(),s=(n=(t=(i=r==null?void 0:r.astNode)!==null&&i!==void 0?i:r==null?void 0:r.getQueryType())!==null&&t!==void 0?t:r==null?void 0:r.getMutationType())!==null&&n!==void 0?n:r==null?void 0:r.getSubscriptionType();let a=0;return{SchemaDefinition(o){if(s){e.reportError(new p("Cannot define a new schema within a schema extension.",{nodes:o}));return}a>0&&e.reportError(new p("Must provide only one schema definition.",{nodes:o})),++a}}}function Tn(e){const n=Object.create(null),t=[],i=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(s){return r(s),!1}};function r(s){if(n[s.name.value])return;const a=s.name.value;n[a]=!0;const o=e.getFragmentSpreads(s.selectionSet);if(o.length!==0){i[a]=t.length;for(const l of o){const c=l.name.value,f=i[c];if(t.push(l),f===void 0){const d=e.getFragment(c);d&&r(d)}else{const d=t.slice(f),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");e.reportError(new p(`Cannot spread fragment "${c}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}t.pop()}i[a]=void 0}}}function Nn(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const i=e.getRecursiveVariableUsages(t);for(const{node:r}of i){const s=r.name.value;n[s]!==!0&&e.reportError(new p(t.name?`Variable "$${s}" is not defined by operation "${t.name.value}".`:`Variable "$${s}" is not defined.`,{nodes:[r,t]}))}}},VariableDefinition(t){n[t.variable.name.value]=!0}}}function De(e){const n=[],t=[];return{OperationDefinition(i){return n.push(i),!1},FragmentDefinition(i){return t.push(i),!1},Document:{leave(){const i=Object.create(null);for(const r of n)for(const s of e.getRecursivelyReferencedFragments(r))i[s.name.value]=!0;for(const r of t){const s=r.name.value;i[s]!==!0&&e.reportError(new p(`Fragment "${s}" is never used.`,{nodes:r}))}}}}}function vn(e){let n=[];return{OperationDefinition:{enter(){n=[]},leave(t){const i=Object.create(null),r=e.getRecursiveVariableUsages(t);for(const{node:s}of r)i[s.name.value]=!0;for(const s of n){const a=s.variable.name.value;i[a]!==!0&&e.reportError(new p(t.name?`Variable "$${a}" is never used in operation "${t.name.value}".`:`Variable "$${a}" is never used.`,{nodes:s}))}}},VariableDefinition(t){n.push(t)}}}function x(e){switch(e.kind){case u.OBJECT:return{...e,fields:yn(e.fields)};case u.LIST:return{...e,values:e.values.map(x)};case u.INT:case u.FLOAT:case u.STRING:case u.BOOLEAN:case u.NULL:case u.ENUM:case u.VARIABLE:return e}}function yn(e){return e.map(n=>({...n,value:x(n.value)})).sort((n,t)=>de(n.name.value,t.name.value))}function _e(e){return Array.isArray(e)?e.map(([n,t])=>`subfields "${n}" conflict because `+_e(t)).join(" and "):e}function In(e){const n=new bn,t=new Map;return{SelectionSet(i){const r=hn(e,t,n,e.getParentType(),i);for(const[[s,a],o,l]of r){const c=_e(a);e.reportError(new p(`Fields "${s}" conflict because ${c}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:o.concat(l)}))}}}}function hn(e,n,t,i,r){const s=[],[a,o]=Y(e,n,i,r);if(Dn(e,s,n,t,a),o.length!==0)for(let l=0;l<o.length;l++){L(e,s,n,t,!1,a,o[l]);for(let c=l+1;c<o.length;c++)M(e,s,n,t,!1,o[l],o[c])}return s}function L(e,n,t,i,r,s,a){const o=e.getFragment(a);if(!o)return;const[l,c]=K(e,t,o);if(s!==l){ee(e,n,t,i,r,s,l);for(const f of c)i.has(f,a,r)||(i.add(f,a,r),L(e,n,t,i,r,s,f))}}function M(e,n,t,i,r,s,a){if(s===a||i.has(s,a,r))return;i.add(s,a,r);const o=e.getFragment(s),l=e.getFragment(a);if(!o||!l)return;const[c,f]=K(e,t,o),[d,m]=K(e,t,l);ee(e,n,t,i,r,c,d);for(const g of m)M(e,n,t,i,r,s,g);for(const g of f)M(e,n,t,i,r,g,a)}function On(e,n,t,i,r,s,a,o){const l=[],[c,f]=Y(e,n,r,s),[d,m]=Y(e,n,a,o);ee(e,l,n,t,i,c,d);for(const g of m)L(e,l,n,t,i,c,g);for(const g of f)L(e,l,n,t,i,d,g);for(const g of f)for(const N of m)M(e,l,n,t,i,g,N);return l}function Dn(e,n,t,i,r){for(const[s,a]of Object.entries(r))if(a.length>1)for(let o=0;o<a.length;o++)for(let l=o+1;l<a.length;l++){const c=be(e,t,i,!1,s,a[o],a[l]);c&&n.push(c)}}function ee(e,n,t,i,r,s,a){for(const[o,l]of Object.entries(s)){const c=a[o];if(c)for(const f of l)for(const d of c){const m=be(e,t,i,r,o,f,d);m&&n.push(m)}}}function be(e,n,t,i,r,s,a){const[o,l,c]=s,[f,d,m]=a,g=i||o!==f&&F(o)&&F(f);if(!g){const A=l.name.value,ie=d.name.value;if(A!==ie)return[[r,`"${A}" and "${ie}" are different fields`],[l],[d]];if(ae(l)!==ae(d))return[[r,"they have differing arguments"],[l],[d]]}const N=c==null?void 0:c.type,S=m==null?void 0:m.type;if(N&&S&&H(N,S))return[[r,`they return conflicting types "${E(N)}" and "${E(S)}"`],[l],[d]];const ne=l.selectionSet,te=d.selectionSet;if(ne&&te){const A=On(e,n,t,g,O(N),ne,O(S),te);return _n(A,r,l,d)}}function ae(e){var n;const t=(n=e.arguments)!==null&&n!==void 0?n:[],i={kind:u.OBJECT,fields:t.map(r=>({kind:u.OBJECT_FIELD,name:r.name,value:r.value}))};return v(x(i))}function H(e,n){return k(e)?k(n)?H(e.ofType,n.ofType):!0:k(n)?!0:I(e)?I(n)?H(e.ofType,n.ofType):!0:I(n)?!0:U(e)||U(n)?e!==n:!1}function Y(e,n,t,i){const r=n.get(i);if(r)return r;const s=Object.create(null),a=Object.create(null);Se(e,t,i,s,a);const o=[s,Object.keys(a)];return n.set(i,o),o}function K(e,n,t){const i=n.get(t.selectionSet);if(i)return i;const r=h(e.getSchema(),t.typeCondition);return Y(e,n,r,t.selectionSet)}function Se(e,n,t,i,r){for(const s of t.selections)switch(s.kind){case u.FIELD:{const a=s.name.value;let o;(F(n)||w(n))&&(o=n.getFields()[a]);const l=s.alias?s.alias.value:a;i[l]||(i[l]=[]),i[l].push([n,s,o]);break}case u.FRAGMENT_SPREAD:r[s.name.value]=!0;break;case u.INLINE_FRAGMENT:{const a=s.typeCondition,o=a?h(e.getSchema(),a):n;Se(e,o,s.selectionSet,i,r);break}}}function _n(e,n,t,i){if(e.length>0)return[[n,e.map(([r])=>r)],[t,...e.map(([,r])=>r).flat()],[i,...e.map(([,,r])=>r).flat()]]}class bn{constructor(){this._data=new Map}has(n,t,i){var r;const[s,a]=n<t?[n,t]:[t,n],o=(r=this._data.get(s))===null||r===void 0?void 0:r.get(a);return o===void 0?!1:i?!0:i===o}add(n,t,i){const[r,s]=n<t?[n,t]:[t,n],a=this._data.get(r);a===void 0?this._data.set(r,new Map([[s,i]])):a.set(s,i)}}function Sn(e){return{InlineFragment(n){const t=e.getType(),i=e.getParentType();if($(t)&&$(i)&&!re(e.getSchema(),t,i)){const r=E(i),s=E(t);e.reportError(new p(`Fragment cannot be spread here as objects of type "${r}" can never be of type "${s}".`,{nodes:n}))}},FragmentSpread(n){const t=n.name.value,i=wn(e,t),r=e.getParentType();if(i&&r&&!re(e.getSchema(),i,r)){const s=E(r),a=E(i);e.reportError(new p(`Fragment "${t}" cannot be spread here as objects of type "${s}" can never be of type "${a}".`,{nodes:n}))}}}}function wn(e,n){const t=e.getFragment(n);if(t){const i=h(e.getSchema(),t.typeCondition);if($(i))return i}}function Fn(e){const n=e.getSchema(),t=Object.create(null);for(const r of e.getDocument().definitions)q(r)&&(t[r.name.value]=r);return{ScalarTypeExtension:i,ObjectTypeExtension:i,InterfaceTypeExtension:i,UnionTypeExtension:i,EnumTypeExtension:i,InputObjectTypeExtension:i};function i(r){const s=r.name.value,a=t[s],o=n==null?void 0:n.getType(s);let l;if(a?l=Rn[a.kind]:o&&(l=$n(o)),l){if(l!==r.kind){const c=Cn(r.kind);e.reportError(new p(`Cannot extend non-${c} type "${s}".`,{nodes:a?[a,r]:r}))}}else{const c=Object.keys({...t,...n==null?void 0:n.getTypeMap()}),f=R(s,c);e.reportError(new p(`Cannot extend type "${s}" because it is not defined.`+_(f),{nodes:r.name}))}}}const Rn={[u.SCALAR_TYPE_DEFINITION]:u.SCALAR_TYPE_EXTENSION,[u.OBJECT_TYPE_DEFINITION]:u.OBJECT_TYPE_EXTENSION,[u.INTERFACE_TYPE_DEFINITION]:u.INTERFACE_TYPE_EXTENSION,[u.UNION_TYPE_DEFINITION]:u.UNION_TYPE_EXTENSION,[u.ENUM_TYPE_DEFINITION]:u.ENUM_TYPE_EXTENSION,[u.INPUT_OBJECT_TYPE_DEFINITION]:u.INPUT_OBJECT_TYPE_EXTENSION};function $n(e){if(Ye(e))return u.SCALAR_TYPE_EXTENSION;if(F(e))return u.OBJECT_TYPE_EXTENSION;if(w(e))return u.INTERFACE_TYPE_EXTENSION;if(Be(e))return u.UNION_TYPE_EXTENSION;if(pe(e))return u.ENUM_TYPE_EXTENSION;if(C(e))return u.INPUT_OBJECT_TYPE_EXTENSION;y(!1,"Unexpected type: "+E(e))}function Cn(e){switch(e){case u.SCALAR_TYPE_EXTENSION:return"scalar";case u.OBJECT_TYPE_EXTENSION:return"object";case u.INTERFACE_TYPE_EXTENSION:return"interface";case u.UNION_TYPE_EXTENSION:return"union";case u.ENUM_TYPE_EXTENSION:return"enum";case u.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:y(!1,"Unexpected kind: "+E(e))}}function An(e){return{...Pn(e),Field:{leave(n){var t;const i=e.getFieldDef();if(!i)return!1;const r=new Set((t=n.arguments)===null||t===void 0?void 0:t.map(s=>s.name.value));for(const s of i.args)if(!r.has(s.name)&&me(s)){const a=E(s.type);e.reportError(new p(`Field "${i.name}" argument "${s.name}" of type "${a}" is required, but it was not provided.`,{nodes:n}))}}}}}function Pn(e){var n;const t=Object.create(null),i=e.getSchema(),r=(n=i==null?void 0:i.getDirectives())!==null&&n!==void 0?n:X;for(const o of r)t[o.name]=V(o.args.filter(me),l=>l.name);const s=e.getDocument().definitions;for(const o of s)if(o.kind===u.DIRECTIVE_DEFINITION){var a;const l=(a=o.arguments)!==null&&a!==void 0?a:[];t[o.name.value]=V(l.filter(kn),c=>c.name.value)}return{Directive:{leave(o){const l=o.name.value,c=t[l];if(c){var f;const d=(f=o.arguments)!==null&&f!==void 0?f:[],m=new Set(d.map(g=>g.name.value));for(const[g,N]of Object.entries(c))if(!m.has(g)){const S=Xe(N.type)?E(N.type):v(N.type);e.reportError(new p(`Directive "@${l}" argument "${g}" of type "${S}" is required, but it was not provided.`,{nodes:o}))}}}}}}function kn(e){return e.type.kind===u.NON_NULL_TYPE&&e.defaultValue==null}function Un(e){return{Field(n){const t=e.getType(),i=n.selectionSet;if(t){if(U(O(t))){if(i){const r=n.name.value,s=E(t);e.reportError(new p(`Field "${r}" must not have a selection since type "${s}" has no subfields.`,{nodes:i}))}}else if(!i){const r=n.name.value,s=E(t);e.reportError(new p(`Field "${r}" of type "${s}" must have a selection of subfields. Did you mean "${r} { ... }"?`,{nodes:n}))}}}}}function Vn(e,n,t){var i;const r={},s=(i=n.arguments)!==null&&i!==void 0?i:[],a=V(s,o=>o.name.value);for(const o of e.args){const l=o.name,c=o.type,f=a[l];if(!f){if(o.defaultValue!==void 0)r[l]=o.defaultValue;else if(I(c))throw new p(`Argument "${l}" of required type "${E(c)}" was not provided.`,{nodes:n});continue}const d=f.value;let m=d.kind===u.NULL;if(d.kind===u.VARIABLE){const N=d.name.value;if(t==null||!jn(t,N)){if(o.defaultValue!==void 0)r[l]=o.defaultValue;else if(I(c))throw new p(`Argument "${l}" of required type "${E(c)}" was provided the variable "$${N}" which was not provided a runtime value.`,{nodes:d});continue}m=t[N]==null}if(m&&I(c))throw new p(`Argument "${l}" of non-null type "${E(c)}" must not be null.`,{nodes:d});const g=qe(d,c,t);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${v(d)}.`,{nodes:d});r[l]=g}return r}function le(e,n,t){var i;const r=(i=n.directives)===null||i===void 0?void 0:i.find(s=>s.name.value===e.name);if(r)return Vn(e,r,t)}function jn(e,n){return Object.prototype.hasOwnProperty.call(e,n)}function Ln(e,n,t,i,r){const s=new Map;return W(e,n,t,i,r,s,new Set),s}function W(e,n,t,i,r,s,a){for(const o of r.selections)switch(o.kind){case u.FIELD:{if(!Q(t,o))continue;const l=Mn(o),c=s.get(l);c!==void 0?c.push(o):s.set(l,[o]);break}case u.INLINE_FRAGMENT:{if(!Q(t,o)||!ce(e,o,i))continue;W(e,n,t,i,o.selectionSet,s,a);break}case u.FRAGMENT_SPREAD:{const l=o.name.value;if(a.has(l)||!Q(t,o))continue;a.add(l);const c=n[l];if(!c||!ce(e,c,i))continue;W(e,n,t,i,c.selectionSet,s,a);break}}}function Q(e,n){const t=le(Ge,n,e);if((t==null?void 0:t.if)===!0)return!1;const i=le(Je,n,e);return(i==null?void 0:i.if)!==!1}function ce(e,n,t){const i=n.typeCondition;if(!i)return!0;const r=h(e,i);return r===t?!0:fe(r)?e.isSubType(r,t):!1}function Mn(e){return e.alias?e.alias.value:e.name.value}function Yn(e){return{OperationDefinition(n){if(n.operation==="subscription"){const t=e.getSchema(),i=t.getSubscriptionType();if(i){const r=n.name?n.name.value:null,s=Object.create(null),a=e.getDocument(),o=Object.create(null);for(const c of a.definitions)c.kind===u.FRAGMENT_DEFINITION&&(o[c.name.value]=c);const l=Ln(t,o,s,i,n.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();e.reportError(new p(r!=null?`Subscription "${r}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const c of l.values())c[0].name.value.startsWith("__")&&e.reportError(new p(r!=null?`Subscription "${r}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:c}))}}}}}function we(e,n){const t=new Map;for(const i of e){const r=n(i),s=t.get(r);s===void 0?t.set(r,[i]):s.push(i)}return t}function Fe(e){return{Field:n,Directive:n};function n(t){var i;const r=(i=t.arguments)!==null&&i!==void 0?i:[],s=we(r,a=>a.name.value);for(const[a,o]of s)o.length>1&&e.reportError(new p(`There can be only one argument named "${a}".`,{nodes:o.map(l=>l.name)}))}}function Bn(e){const n=Object.create(null),t=e.getSchema();return{DirectiveDefinition(i){const r=i.name.value;if(t!=null&&t.getDirective(r)){e.reportError(new p(`Directive "@${r}" already exists in the schema. It cannot be redefined.`,{nodes:i.name}));return}return n[r]?e.reportError(new p(`There can be only one directive named "@${r}".`,{nodes:[n[r],i.name]})):n[r]=i.name,!1}}}function Re(e){const n=Object.create(null),t=e.getSchema(),i=t?t.getDirectives():X;for(const o of i)n[o.name]=!o.isRepeatable;const r=e.getDocument().definitions;for(const o of r)o.kind===u.DIRECTIVE_DEFINITION&&(n[o.name.value]=!o.repeatable);const s=Object.create(null),a=Object.create(null);return{enter(o){if(!("directives"in o)||!o.directives)return;let l;if(o.kind===u.SCHEMA_DEFINITION||o.kind===u.SCHEMA_EXTENSION)l=s;else if(q(o)||ve(o)){const c=o.name.value;l=a[c],l===void 0&&(a[c]=l=Object.create(null))}else l=Object.create(null);for(const c of o.directives){const f=c.name.value;n[f]&&(l[f]?e.reportError(new p(`The directive "@${f}" can only be used once at this location.`,{nodes:[l[f],c]})):l[f]=c)}}}}function Xn(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),i=Object.create(null);return{EnumTypeDefinition:r,EnumTypeExtension:r};function r(s){var a;const o=s.name.value;i[o]||(i[o]=Object.create(null));const l=(a=s.values)!==null&&a!==void 0?a:[],c=i[o];for(const f of l){const d=f.name.value,m=t[o];pe(m)&&m.getValue(d)?e.reportError(new p(`Enum value "${o}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):c[d]?e.reportError(new p(`Enum value "${o}.${d}" can only be defined once.`,{nodes:[c[d],f.name]})):c[d]=f.name}return!1}}function qn(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),i=Object.create(null);return{InputObjectTypeDefinition:r,InputObjectTypeExtension:r,InterfaceTypeDefinition:r,InterfaceTypeExtension:r,ObjectTypeDefinition:r,ObjectTypeExtension:r};function r(s){var a;const o=s.name.value;i[o]||(i[o]=Object.create(null));const l=(a=s.fields)!==null&&a!==void 0?a:[],c=i[o];for(const f of l){const d=f.name.value;Gn(t[o],d)?e.reportError(new p(`Field "${o}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):c[d]?e.reportError(new p(`Field "${o}.${d}" can only be defined once.`,{nodes:[c[d],f.name]})):c[d]=f.name}return!1}}function Gn(e,n){return F(e)||w(e)||C(e)?e.getFields()[n]!=null:!1}function Jn(e){const n=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(t){const i=t.name.value;return n[i]?e.reportError(new p(`There can be only one fragment named "${i}".`,{nodes:[n[i],t.name]})):n[i]=t.name,!1}}}function $e(e){const n=[];let t=Object.create(null);return{ObjectValue:{enter(){n.push(t),t=Object.create(null)},leave(){const i=n.pop();i||y(!1),t=i}},ObjectField(i){const r=i.name.value;t[r]?e.reportError(new p(`There can be only one input field named "${r}".`,{nodes:[t[r],i.name]})):t[r]=i.name}}}function Qn(e){const n=Object.create(null);return{OperationDefinition(t){const i=t.name;return i&&(n[i.value]?e.reportError(new p(`There can be only one operation named "${i.value}".`,{nodes:[n[i.value],i]})):n[i.value]=i),!1},FragmentDefinition:()=>!1}}function Hn(e){const n=e.getSchema(),t=Object.create(null),i=n?{query:n.getQueryType(),mutation:n.getMutationType(),subscription:n.getSubscriptionType()}:{};return{SchemaDefinition:r,SchemaExtension:r};function r(s){var a;const o=(a=s.operationTypes)!==null&&a!==void 0?a:[];for(const l of o){const c=l.operation,f=t[c];i[c]?e.reportError(new p(`Type for ${c} already defined in the schema. It cannot be redefined.`,{nodes:l})):f?e.reportError(new p(`There can be only one ${c} type in schema.`,{nodes:[f,l]})):t[c]=l}return!1}}function Kn(e){const n=Object.create(null),t=e.getSchema();return{ScalarTypeDefinition:i,ObjectTypeDefinition:i,InterfaceTypeDefinition:i,UnionTypeDefinition:i,EnumTypeDefinition:i,InputObjectTypeDefinition:i};function i(r){const s=r.name.value;if(t!=null&&t.getType(s)){e.reportError(new p(`Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:r.name}));return}return n[s]?e.reportError(new p(`There can be only one type named "${s}".`,{nodes:[n[s],r.name]})):n[s]=r.name,!1}}function Wn(e){return{OperationDefinition(n){var t;const i=(t=n.variableDefinitions)!==null&&t!==void 0?t:[],r=we(i,s=>s.variable.name.value);for(const[s,a]of r)a.length>1&&e.reportError(new p(`There can be only one variable named "$${s}".`,{nodes:a.map(o=>o.variable.name)}))}}}function zn(e){return{ListValue(n){const t=Qe(e.getParentInputType());if(!k(t))return D(e,n),!1},ObjectValue(n){const t=O(e.getInputType());if(!C(t))return D(e,n),!1;const i=V(n.fields,r=>r.name.value);for(const r of Object.values(t.getFields()))if(!i[r.name]&&He(r)){const a=E(r.type);e.reportError(new p(`Field "${t.name}.${r.name}" of required type "${a}" was not provided.`,{nodes:n}))}},ObjectField(n){const t=O(e.getParentInputType());if(!e.getInputType()&&C(t)){const r=R(n.name.value,Object.keys(t.getFields()));e.reportError(new p(`Field "${n.name.value}" is not defined by type "${t.name}".`+_(r),{nodes:n}))}},NullValue(n){const t=e.getInputType();I(t)&&e.reportError(new p(`Expected value of type "${E(t)}", found ${v(n)}.`,{nodes:n}))},EnumValue:n=>D(e,n),IntValue:n=>D(e,n),FloatValue:n=>D(e,n),StringValue:n=>D(e,n),BooleanValue:n=>D(e,n)}}function D(e,n){const t=e.getInputType();if(!t)return;const i=O(t);if(!U(i)){const r=E(t);e.reportError(new p(`Expected value of type "${r}", found ${v(n)}.`,{nodes:n}));return}try{if(i.parseLiteral(n,void 0)===void 0){const s=E(t);e.reportError(new p(`Expected value of type "${s}", found ${v(n)}.`,{nodes:n}))}}catch(r){const s=E(t);r instanceof p?e.reportError(r):e.reportError(new p(`Expected value of type "${s}", found ${v(n)}; `+r.message,{nodes:n,originalError:r}))}}function Zn(e){return{VariableDefinition(n){const t=h(e.getSchema(),n.type);if(t!==void 0&&!Ke(t)){const i=n.variable.name.value,r=v(n.type);e.reportError(new p(`Variable "$${i}" cannot be non-input type "${r}".`,{nodes:n.type}))}}}}function xn(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const i=e.getRecursiveVariableUsages(t);for(const{node:r,type:s,defaultValue:a}of i){const o=r.name.value,l=n[o];if(l&&s){const c=e.getSchema(),f=h(c,l.type);if(f&&!et(c,f,l.defaultValue,s,a)){const d=E(f),m=E(s);e.reportError(new p(`Variable "$${o}" of type "${d}" used in position expecting type "${m}".`,{nodes:[l,r]}))}}}}},VariableDefinition(t){n[t.variable.name.value]=t}}}function et(e,n,t,i,r){if(I(i)&&!I(n)){if(!(t!=null&&t.kind!==u.NULL)&&!(r!==void 0))return!1;const o=i.ofType;return se(e,n,o)}return se(e,n,i)}const Ce=Object.freeze([ye,Qn,gn,Yn,Oe,cn,Zn,Un,on,Jn,he,De,Sn,Tn,Wn,Nn,vn,Ie,Re,un,Fe,zn,An,xn,In,$e]);class nt{constructor(n,t){this._ast=n,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=t}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(n){this._onError(n)}getDocument(){return this._ast}getFragment(n){let t;if(this._fragments)t=this._fragments;else{t=Object.create(null);for(const i of this.getDocument().definitions)i.kind===u.FRAGMENT_DEFINITION&&(t[i.name.value]=i);this._fragments=t}return t[n]}getFragmentSpreads(n){let t=this._fragmentSpreads.get(n);if(!t){t=[];const i=[n];let r;for(;r=i.pop();)for(const s of r.selections)s.kind===u.FRAGMENT_SPREAD?t.push(s):s.selectionSet&&i.push(s.selectionSet);this._fragmentSpreads.set(n,t)}return t}getRecursivelyReferencedFragments(n){let t=this._recursivelyReferencedFragments.get(n);if(!t){t=[];const i=Object.create(null),r=[n.selectionSet];let s;for(;s=r.pop();)for(const a of this.getFragmentSpreads(s)){const o=a.name.value;if(i[o]!==!0){i[o]=!0;const l=this.getFragment(o);l&&(t.push(l),r.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(n,t)}return t}}class tt extends nt{constructor(n,t,i,r){super(t,r),this._schema=n,this._typeInfo=i,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(n){let t=this._variableUsages.get(n);if(!t){const i=[],r=new ge(this._schema);Ee(n,Te(r,{VariableDefinition:()=>!1,Variable(s){i.push({node:s,type:r.getInputType(),defaultValue:r.getDefaultValue()})}})),t=i,this._variableUsages.set(n,t)}return t}getRecursiveVariableUsages(n){let t=this._recursiveVariableUsages.get(n);if(!t){t=this.getVariableUsages(n);for(const i of this.getRecursivelyReferencedFragments(n))t=t.concat(this.getVariableUsages(i));this._recursiveVariableUsages.set(n,t)}return t}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Ae(e,n,t=Ce,i,r=new ge(e)){var s;const a=(s=i==null?void 0:i.maxErrors)!==null&&s!==void 0?s:100;n||We(!1,"Must provide document."),ze(e);const o=Object.freeze({}),l=[],c=new tt(e,n,r,d=>{if(l.length>=a)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),o;l.push(d)}),f=Ze(t.map(d=>d(c)));try{Ee(n,Te(r,f))}catch(d){if(d!==o)throw d}return l}function it(e){return{Field(n){const t=e.getFieldDef(),i=t==null?void 0:t.deprecationReason;if(t&&i!=null){const r=e.getParentType();r!=null||y(!1),e.reportError(new p(`The field ${r.name}.${t.name} is deprecated. ${i}`,{nodes:n}))}},Argument(n){const t=e.getArgument(),i=t==null?void 0:t.deprecationReason;if(t&&i!=null){const r=e.getDirective();if(r!=null)e.reportError(new p(`Directive "@${r.name}" argument "${t.name}" is deprecated. ${i}`,{nodes:n}));else{const s=e.getParentType(),a=e.getFieldDef();s!=null&&a!=null||y(!1),e.reportError(new p(`Field "${s.name}.${a.name}" argument "${t.name}" is deprecated. ${i}`,{nodes:n}))}}},ObjectField(n){const t=O(e.getParentInputType());if(C(t)){const i=t.getFields()[n.name.value],r=i==null?void 0:i.deprecationReason;r!=null&&e.reportError(new p(`The input field ${t.name}.${i.name} is deprecated. ${r}`,{nodes:n}))}},EnumValue(n){const t=e.getEnumValue(),i=t==null?void 0:t.deprecationReason;if(t&&i!=null){const r=O(e.getInputType());r!=null||y(!1),e.reportError(new p(`The enum value "${r.name}.${t.name}" is deprecated. ${i}`,{nodes:n}))}}}}var rt=Object.defineProperty,b=(e,n)=>rt(e,"name",{value:n,configurable:!0});const st=[En,Hn,Kn,Xn,qn,Bn,Oe,Ie,Re,Fn,Fe,$e];function Pe(e,n,t,i,r){const s=Ce.filter(o=>!(o===De||o===ye||i&&o===he));return t&&Array.prototype.push.apply(s,t),r&&Array.prototype.push.apply(s,st),Ae(e,n,s).filter(o=>{if(o.message.includes("Unknown directive")&&o.nodes){const l=o.nodes[0];if(l&&l.kind===u.DIRECTIVE){const c=l.name.value;if(c==="arguments"||c==="argumentDefinitions")return!1}}return!0})}b(Pe,"validateWithCustomRules");const P={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},z={[P.Error]:1,[P.Warning]:2,[P.Information]:3,[P.Hint]:4},B=b((e,n)=>{if(!e)throw new Error(n)},"invariant");function ke(e,n=null,t,i,r){var s,a;let o=null,l="";r&&(l=typeof r=="string"?r:r.reduce((f,d)=>f+v(d)+`

`,""));const c=l?`${e}

${l}`:e;try{o=xe(c)}catch(f){if(f instanceof p){const d=Ve((a=(s=f.locations)===null||s===void 0?void 0:s[0])!==null&&a!==void 0?a:{line:0,column:0},c);return[{severity:z.Error,message:f.message,source:"GraphQL: Syntax",range:d}]}throw f}return Ue(o,n,t,i)}b(ke,"getDiagnostics");function Ue(e,n=null,t,i){if(!n)return[];const r=Pe(n,e,t,i).flatMap(a=>Z(a,z.Error,"Validation")),s=Ae(n,e,[it]).flatMap(a=>Z(a,z.Warning,"Deprecation"));return r.concat(s)}b(Ue,"validateQuery");function Z(e,n,t){if(!e.nodes)return[];const i=[];for(const[r,s]of e.nodes.entries()){const a=s.kind!=="Variable"&&"name"in s&&s.name!==void 0?s.name:"variable"in s&&s.variable!==void 0?s.variable:s;if(a){B(e.locations,"GraphQL validation error requires locations.");const o=e.locations[r],l=je(a),c=o.column+(l.end-l.start);i.push({source:`GraphQL: ${t}`,message:e.message,severity:n,range:new Ne(new j(o.line-1,o.column-1),new j(o.line-1,c))})}}return i}b(Z,"annotations");function Ve(e,n){const t=nn(),i=t.startState(),r=n.split(`
`);B(r.length>=e.line,"Query text must have more lines than where the error happened");let s=null;for(let c=0;c<e.line;c++)for(s=new en(r[c]);!s.eol()&&t.token(s,i)!=="invalidchar";);B(s,"Expected Parser stream to be available.");const a=e.line-1,o=s.getStartOfToken(),l=s.getCurrentPosition();return new Ne(new j(a,o),new j(a,l))}b(Ve,"getRange");function je(e){const t=e.loc;return B(t,"Expected ASTNode to have a location."),t}b(je,"getLocation");const ue=["error","warning","information","hint"],ot={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};G.registerHelper("lint","graphql",(e,n)=>{const{schema:t,validationRules:i,externalFragments:r}=n;return ke(e,t,i,void 0,r).map(o=>({message:o.message,severity:o.severity?ue[o.severity-1]:ue[0],type:o.source?ot[o.source]:void 0,from:G.Pos(o.range.start.line,o.range.start.character),to:G.Pos(o.range.end.line,o.range.end.character)}))});
