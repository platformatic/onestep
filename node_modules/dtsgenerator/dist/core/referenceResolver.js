"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("cross-fetch/polyfill");
const debug_1 = tslib_1.__importDefault(require("debug"));
const jsonSchema_1 = require("./jsonSchema");
const schemaId_1 = tslib_1.__importDefault(require("./schemaId"));
const type_1 = require("./type");
const debug = (0, debug_1.default)('dtsgen');
class ReferenceResolver {
    constructor() {
        this.schemaCache = new Map();
        this.referenceCache = new Map();
    }
    dereference(refId) {
        const result = this.referenceCache.get(refId);
        if (result == null) {
            throw new Error('Target reference is not found: ' + refId);
        }
        return result;
    }
    getAllRegisteredSchema() {
        return this.schemaCache.values();
    }
    getAllRegisteredIdAndSchema() {
        return this.schemaCache.entries();
    }
    async resolve() {
        debug(`resolve reference: reference schema count=${this.referenceCache.size}.`);
        const error = [];
        for (const [key, schema] of this.referenceCache.entries()) {
            if (schema != null) {
                continue;
            }
            const id = new schemaId_1.default(key);
            const fileId = id.getFileId();
            let result = this.schemaCache.get(id.getAbsoluteId());
            if (result == null) {
                const refSchema = this.schemaCache.get(fileId);
                debug(`get from schema cache, fileId=${fileId}, exists=${String(!!refSchema)}, ${id.getAbsoluteId()}`);
                if (refSchema == null && id.isFetchable()) {
                    try {
                        debug(`fetch remote schema: id=[${fileId}].`);
                        const s = await (0, type_1.readSchemaFromUrl)(fileId);
                        this.registerSchema(s);
                    }
                    catch (e) {
                        error.push(`Fail to fetch the $ref target: ${id.getAbsoluteId()}, ${String(e)}`);
                        continue;
                    }
                }
                result = this.schemaCache.get(id.getAbsoluteId());
            }
            debug(`resolve reference: ref=[${id.getAbsoluteId()}]`);
            if (result != null) {
                this.referenceCache.set(id.getAbsoluteId(), result);
            }
            else {
                if (id.existsJsonPointerHash()) {
                    const rootSchema = this.searchParentSchema(id);
                    if (rootSchema == null) {
                        error.push(`The $ref targets root is not found: ${id.getAbsoluteId()}`);
                        continue;
                    }
                    const targetSchema = (0, jsonSchema_1.getSubSchema)(rootSchema, id.getJsonPointerHash(), id);
                    this.addSchema(targetSchema);
                    this.registerSchema(targetSchema);
                    this.referenceCache.set(id.getAbsoluteId(), targetSchema);
                }
                else {
                    error.push(`The $ref target is not found: ${id.getAbsoluteId()}`);
                    continue;
                }
            }
        }
        if (error.length > 0) {
            throw new Error(error.join('\n'));
        }
    }
    searchParentSchema(id) {
        const fileId = id.getFileId();
        const rootSchema = this.schemaCache.get(fileId);
        if (rootSchema != null) {
            return rootSchema;
        }
        const key = id.getAbsoluteId();
        for (const k of this.schemaCache.keys()) {
            if (key.startsWith(k)) {
                const s = this.schemaCache.get(k);
                if (s === null || s === void 0 ? void 0 : s.rootSchema) {
                    return s.rootSchema;
                }
            }
        }
        return;
    }
    registerSchema(schema) {
        debug(`register schema: schemaId=[${schema.id.getAbsoluteId()}].`);
        (0, jsonSchema_1.searchAllSubSchema)(schema, (subSchema) => {
            this.addSchema(subSchema);
        }, (refId) => {
            this.addReference(refId);
        });
    }
    addSchema(schema) {
        const id = schema.id;
        const key = id.getAbsoluteId();
        if (!this.schemaCache.has(key)) {
            debug(` add schema: id=${key}`);
            this.schemaCache.set(key, schema);
            if (schema.rootSchema == null) {
                const fileId = id.getFileId();
                if (!this.schemaCache.has(fileId)) {
                    this.schemaCache.set(fileId, schema);
                }
            }
        }
    }
    addReference(refId) {
        if (!this.referenceCache.has(refId.getAbsoluteId())) {
            debug(` add reference: id=${refId.getAbsoluteId()}`);
            this.referenceCache.set(refId.getAbsoluteId(), undefined);
        }
    }
    clear() {
        debug('clear resolver cache.');
        this.schemaCache.clear();
        this.referenceCache.clear();
    }
}
exports.default = ReferenceResolver;
