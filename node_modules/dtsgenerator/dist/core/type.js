"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPlugin = exports.parseFileContent = exports.readSchemaFromUrl = exports.readSchemasFromFile = exports.readSchemaFromStdin = exports.parseSchema = exports.isJsonSchemaDraft04 = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path_1 = require("path");
const js_yaml_1 = require("js-yaml");
const utils_1 = require("../utils");
const jsonSchema_1 = require("./jsonSchema");
const schemaId_1 = tslib_1.__importDefault(require("./schemaId"));
exports.ts = require("typescript");
function isJsonSchemaDraft04(_content, type) {
    return type === 'Draft04';
}
exports.isJsonSchemaDraft04 = isJsonSchemaDraft04;
function parseSchema(content, url) {
    const { type, openApiVersion } = (0, jsonSchema_1.selectSchemaType)(content);
    let id;
    if (typeof content !== 'boolean') {
        if (url != null) {
            (0, jsonSchema_1.setId)(type, content, url);
        }
        id = (0, jsonSchema_1.getId)(type, content);
    }
    return {
        type,
        openApiVersion,
        id: id ? new schemaId_1.default(id) : schemaId_1.default.empty,
        content,
    };
}
exports.parseSchema = parseSchema;
async function readSchemaFromStdin() {
    const data = await (0, utils_1.readStream)(process.stdin);
    const content = parseFileContent(data);
    return parseSchema(content);
}
exports.readSchemaFromStdin = readSchemaFromStdin;
async function readSchemasFromFile(pattern) {
    const files = await (0, utils_1.globFiles)(pattern);
    return Promise.all(files.map(async (file) => {
        const data = await fs.promises.readFile(file, {
            encoding: 'utf8',
        });
        const content = parseFileContent(data);
        return parseSchema(content);
    }));
}
exports.readSchemasFromFile = readSchemasFromFile;
async function readSchemaFromUrl(url) {
    const data = await (0, utils_1.readUrl)(url);
    const content = parseFileContent(data, url);
    return parseSchema(content, url);
}
exports.readSchemaFromUrl = readSchemaFromUrl;
function parseFileContent(content, filename) {
    const ext = filename ? (0, path_1.extname)(filename).toLowerCase() : '';
    const maybeYaml = ext === '.yaml' || ext === '.yml';
    try {
        if (maybeYaml) {
            return deepCopy((0, js_yaml_1.load)(content));
        }
        else {
            return JSON.parse(content);
        }
    }
    catch (e) {
        if (maybeYaml) {
            return JSON.parse(content);
        }
        else {
            return deepCopy((0, js_yaml_1.load)(content));
        }
    }
}
exports.parseFileContent = parseFileContent;
function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
async function loadPlugin(name, option) {
    if (!option) {
        return undefined;
    }
    const mod = (await (_a = name, Promise.resolve().then(() => tslib_1.__importStar(require(_a)))));
    if (!mod.default) {
        console.warn(`The plugin (${name}) is invalid module. That is not default export format.`);
        return undefined;
    }
    const plugin = mod.default;
    if (plugin.preProcess != null && typeof plugin.preProcess !== 'function') {
        console.warn(`The plugin (${name}) is invalid module. The 'preProcess' is not a function.`);
        return undefined;
    }
    if (plugin.postProcess != null &&
        typeof plugin.postProcess !== 'function') {
        console.warn(`The plugin (${name}) is invalid module. The 'postProcess' is not a function.`);
        return undefined;
    }
    return plugin;
}
exports.loadPlugin = loadPlugin;
