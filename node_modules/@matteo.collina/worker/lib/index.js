"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const bindings_1 = __importDefault(require("bindings"));
const events_1 = require("events");
const fs_1 = __importDefault(require("fs"));
const { SynchronousWorkerImpl, UV_RUN_DEFAULT, UV_RUN_ONCE, UV_RUN_NOWAIT } = (0, bindings_1.default)('synchronous_worker');
const kHandle = Symbol('kHandle');
const kProcess = Symbol('kProcess');
const kModule = Symbol('kModule');
const kGlobalThis = Symbol('kGlobalThis');
const kHasOwnEventLoop = Symbol('kHasOwnEventLoop');
const kHasOwnMicrotaskQueue = Symbol('kHasOwnMicrotaskQueue');
const kPromiseInspector = Symbol('kPromiseInspector');
const kStoppedPromise = Symbol('kStoppedPromise');
class SynchronousWorker extends events_1.EventEmitter {
    constructor(options) {
        super();
        this[kHasOwnEventLoop] = !(options === null || options === void 0 ? void 0 : options.sharedEventLoop);
        this[kHasOwnMicrotaskQueue] = !(options === null || options === void 0 ? void 0 : options.sharedMicrotaskQueue);
        this[kHandle] = new SynchronousWorkerImpl();
        this[kHandle].onexit = (code) => {
            this.stop();
            this.emit('exit', code);
        };
        try {
            this[kHandle].start(this[kHasOwnEventLoop], this[kHasOwnMicrotaskQueue]);
            this[kHandle].load((process, nativeRequire, globalThis) => {
                const origExit = process.reallyExit;
                process.reallyExit = (...args) => {
                    const ret = origExit.call(process, ...args);
                    process.memoryUsage();
                    return ret;
                };
                this[kProcess] = process;
                this[kModule] = nativeRequire('module');
                this[kGlobalThis] = globalThis;
                process.on('uncaughtException', (err) => {
                    if (process.listenerCount('uncaughtException') === 1) {
                        this.emit('error', err);
                        process.exit(1);
                    }
                });
            });
        }
        catch (err) {
            this[kHandle].stop();
            throw err;
        }
    }
    runLoop(mode = 'default') {
        if (!this[kHasOwnEventLoop]) {
            throw new Error('Can only use .runLoop() when using a separate event loop');
        }
        let uvMode = UV_RUN_DEFAULT;
        if (mode === 'once')
            uvMode = UV_RUN_ONCE;
        if (mode === 'nowait')
            uvMode = UV_RUN_NOWAIT;
        this[kHandle].runLoop(uvMode);
    }
    runLoopUntilPromiseResolved(promise) {
        var _a;
        if (!this[kHasOwnEventLoop] || !this[kHasOwnMicrotaskQueue]) {
            throw new Error('Can only use .runLoopUntilPromiseResolved() when using a separate event loop and microtask queue');
        }
        (_a = this[kPromiseInspector]) !== null && _a !== void 0 ? _a : (this[kPromiseInspector] = this.createRequire(__filename)('vm').runInThisContext(`(promise => {
      const obj = { state: 'pending', value: null };
      promise.then((v) => { obj.state = 'fulfilled'; obj.value = v; },
                   (v) => { obj.state = 'rejected';  obj.value = v; });
      return obj;
    })`));
        const inspected = this[kPromiseInspector](promise);
        this.runInWorkerScope(() => { });
        while (inspected.state === 'pending') {
            this.runLoop('once');
        }
        if (inspected.state === 'rejected') {
            throw inspected.value;
        }
        return inspected.value;
    }
    get loopAlive() {
        if (!this[kHasOwnEventLoop]) {
            throw new Error('Can only use .loopAlive when using a separate event loop');
        }
        return this[kHandle].isLoopAlive();
    }
    async stop() {
        var _a;
        return (_a = this[kStoppedPromise]) !== null && _a !== void 0 ? _a : (this[kStoppedPromise] = new Promise((resolve, reject) => {
            this[kHandle].signalStop();
            setImmediate(() => {
                fs_1.default.readFile(__filename, () => {
                    try {
                        this[kHandle].stop();
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            });
        }));
    }
    get process() {
        return this[kProcess];
    }
    get globalThis() {
        return this[kGlobalThis];
    }
    createRequire(...args) {
        return this[kModule].createRequire(...args);
    }
    runInWorkerScope(method) {
        return this[kHandle].runInCallbackScope(method);
    }
}
module.exports = SynchronousWorker;
//# sourceMappingURL=index.js.map