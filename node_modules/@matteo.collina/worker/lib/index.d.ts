/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import type Module from 'module';
declare const kHandle: unique symbol;
declare const kProcess: unique symbol;
declare const kModule: unique symbol;
declare const kGlobalThis: unique symbol;
declare const kHasOwnEventLoop: unique symbol;
declare const kHasOwnMicrotaskQueue: unique symbol;
declare const kPromiseInspector: unique symbol;
declare const kStoppedPromise: unique symbol;
interface Options {
    sharedEventLoop: boolean;
    sharedMicrotaskQueue: boolean;
}
type InspectedPromise<T> = {
    state: 'pending';
    value: null;
} | {
    state: 'fulfilled';
    value: T;
} | {
    state: 'rejected';
    value: Error;
};
declare class SynchronousWorker extends EventEmitter {
    [kHandle]: any;
    [kProcess]: NodeJS.Process;
    [kGlobalThis]: any;
    [kModule]: typeof Module;
    [kHasOwnEventLoop]: boolean;
    [kHasOwnMicrotaskQueue]: boolean;
    [kPromiseInspector]: <T>(promise: Promise<T>) => InspectedPromise<T>;
    [kStoppedPromise]: Promise<void>;
    constructor(options?: Partial<Options>);
    runLoop(mode?: 'default' | 'once' | 'nowait'): void;
    runLoopUntilPromiseResolved<T>(promise: Promise<T>): T;
    get loopAlive(): boolean;
    stop(): Promise<void>;
    get process(): NodeJS.Process;
    get globalThis(): any;
    createRequire(...args: Parameters<typeof Module.createRequire>): NodeJS.Require;
    runInWorkerScope(method: () => any): any;
}
export = SynchronousWorker;
